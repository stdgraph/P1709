% algorithms: 
% views: 
% containers: adjacency matrix
% data model: incoming edges on a vertex

\section{Design - Introduction}

Table \ref{tab:name_conv} shows the naming conventions used throughout this document. 

\begin{table}[h!]
\begin{center}
{\begin{tabular}{l l l p{7cm}}
\hline
    \textbf{Template} & & \textbf{Variable} & \\
    \textbf{Parameter} & \textbf{Type Alias} & \textbf{Names} & \textbf{Description} \\
\hline
    \tcode{G} & & & Graph \\
    & \tcode{graph_reference_t<G>} & \tcode{g} & Graph reference \\
    \tcode{GV} &  & \tcode{val} & Graph Value, value or reference \\
\hline
    \tcode{V} & \tcode{vertex_t<G>} & & Vertex \\
    & \tcode{vertex_reference_t<G>} & \tcode{u,v,x,y} & Vertex reference. \tcode{u} is the source (or only) vertex. \tcode{v} is the target vertex. \\
    \tcode{VId} & \tcode{vertex_id_t<G>} & \tcode{uid,vid,seed} & Vertex id. \tcode{uid} is the source (or only) vertex id. \tcode{vid} is the target vertex id. \\
    \tcode{VV} &  \tcode{vertex_value_t<G>} & \tcode{val} & Vertex Value, value or reference. This can be either the user-defined value on a vertex, or a value returned by a function object (e.g. \tcode{VVF}) that is related to the vertex. \\
    \tcode{VR} &  \tcode{vertex_range_t<G>} & \tcode{ur,vr} & Vertex Range \\
    \tcode{VI} & \tcode{vertex_iterator_t<G>} & \tcode{ui,vi} & Vertex Iterator. \tcode{ui} is the source (or only) vertex. \\
                    &  & \tcode{first,last} & \tcode{vi} is the target vertex. \\
    \tcode{VVF} & & \tcode{vvf} & Vertex Value Function: vvf(u) $\rightarrow$ value \\
\hline
    \tcode{E} & \tcode{edge_t<G>} & & Edge \\
    & \tcode{edge_reference_t<G>} & \tcode{uv,vw} & Edge reference. \tcode{uv} is an edge from vertices \tcode{u} to \tcode{v}. \tcode{vw} is an edge from vertices \tcode{v} to \tcode{w}.  \\
    \tcode{EV} &  \tcode{edge_value_t<G>} & \tcode{val} & Edge Value, value or reference. This can be either the user-defined value on an edge, or a value returned by a function object (e.g. \tcode{EVF}) that is related to the edge. \\
    \tcode{ER} &  \tcode{vertex_edge_range_t<G>} & & Edge Range for edges of a vertex \\
    \tcode{EI} & \tcode{vertex_edge_iterator_t<G>} & \tcode{uvi,vwi} & Edge Iterator for an edge of a vertex. \tcode{uvi} is an iterator for an edge from vertices \tcode{u} to \tcode{v}. \tcode{vwi} is an iterator for an edge from vertices \tcode{v} to \tcode{w}. \\
    \tcode{EVF} & & \tcode{evf} & Edge Value Function: evf(uv) $\rightarrow$ value \\
\hline
\end{tabular}}
\caption{Naming Conventions for Types and Variables}
\label{tab:name_conv}
\end{center}
\end{table}

\subsection{Graph Definition}
 A \textit{graph} \cite{REF_graph} $G = (V, E)$ is a set of \textit{vertices} \cite{REF_graph} $V$, \textbf{points} in a space, and \textit{edges} \cite{REF_graph} $E$, \textbf{links} between these vertices. Edges may or may not be \textbf{oriented}, that is, \textit{directed} \cite{REF_graph} or \textit{undirected} \cite{REF_graph}, respectively. Moreover, edges may be \textit{weighted} \cite{REF_graph}, that is, assigned a value. Both \textbf{static} and \textbf{dynamic} implementations of a graph exist, specifically a (static) \textbf{matrix}, each having the typical advantages and disadvantages associated with static and dynamic data structures.

\subsubsection{Adjacency List}
%% adjacency graph, vertex, edge
%% incidence, neighbors (adjacency)
%% optional user-defined values for edge, vertex, graph

\subsubsection{Edge List}
% range with source_id & target_id members, and optional value member(s)
% edgelist view

\subsection{Examples}
\subsubsection{Example: User}
\subsubsection{Example: Graph Author}