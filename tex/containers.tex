
\chapter{Graph Container Implementation}

\section{Relationship between Graphs and Sparse Matrices}


\section{compressed\_graph Graph Container}
The compressed\_graph is a high-performance graph container that uses \href{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_\%28CSR\%2C_CRS_or_Yale_format\%29}{Compressed Sparse Row} format to store it's vertices, edges and associated values. Once constructed, vertices and edges cannot be added or deleted but values on vertices and edges can be modified.
\\

The following listing shows the prototype for the \tcode{compressed_graph}. A fuller description, including its constructors, can be found in the \tcode{<compressed_graph} header section.

Only the constructors, destructor and assignment operators for \tcode{compressed_graph} are public. No other member functions or types are exposed. All other types are only accessible through the types and functions in the Graph Container Interface.

When a value type template argument (EV, VV, GV) is void then no extra overhead is incurred for it. The selection of the VId template argument impacts the inter storage requirements. If you have a small graph where the number of vertices is less than 256, and the number of edges is less than 256, then a \tcode{uint8_t} would be sufficient.

compressed\_graph supports multipartite graphs.

\begin{lstlisting}
template <class    EV     = void,     // Edge Value type
          class    VV     = void,     // Vertex Value type
          class    GV     = void,     // Graph Value type
          integral VId    = uint32_t, // vertex id type
          integral EIndex = uint32_t, // edge index type
          class    Alloc  = allocator<uint32_t>> // for internal containers
class compressed_graph;
\end{lstlisting}

\phil{Must add load\_graph() functions to accomodate loading partitions. 
Need to include specialization for GV=void or non-void. Need to include overloads for partitions.}
