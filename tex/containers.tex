
\chapter{Graph Container Implementation}

\andrew{In think we should have a different name than csr\_graph since: ``CSR'' is a linear algebra concept; a graph does not have ``rows''; the same structure also represents ``CSC''; not calling it csr may avoid some of the discussions we had with linear algebra people.  This has the potential of bogging down the entire proposal.}

\phil{That makes sense. The only counter-argument is that it could be used for matrix representatoin and so removing "CSR" from the name removes the utility it might provide because it's not obvious, but that's a weak argument in comparison.}

\section{Relationship between Graphs and Sparse Matrices}


\section{csr\_graph Graph Container}
The csr\_graph is a high-performance graph container that uses \href{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_\%28CSR\%2C_CRS_or_Yale_format\%29}{Compressed Sparse Row} format to store it's vertices, edges and associated values. Once constructed, vertices and edges cannot be added or deleted but values on vertices and edges can be modified.
\\

The following listing shows the prototype for the \tcode{csr_graph}. A fuller description, including its constructors, can be found in the \tcode{<csr_graph} header section.

Only the constructors, destructor and assignment operators for \tcode{csr_graph} are public. No other member functions or types are exposed. All other types are only accessible through the types and functions in the Graph Container Interface.

When a value type template argument (EV, VV, GV) is void then no extra overhead is incurred for it. The selection of the VId template argument impacts the inter storage requirements. If you have a small graph where the number of vertices is less than 256, and the number of edges is less than 256, then a \tcode{uint8_t} would be sufficient.

csr\_graph supports multipartite graphs.

\begin{lstlisting}
template <class    EV     = void,     // Edge Value type
          class    VV     = void,     // Vertex Value type
          class    GV     = void,     // Graph Value type
          integral VId    = uint32_t, // vertex id type
          integral EIndex = uint32_t, // edge index type
          class    Alloc  = allocator<uint32_t>> // for internal containers
class csr_graph;
\end{lstlisting}

\phil{Must add constructors. Need to include specialization for GV=void or non-void. Need to include overloads for partitions.}
