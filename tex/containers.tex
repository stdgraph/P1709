
\chapter{Graph Container Implementation}

\andrew{In think we should have a different name than csr\_graph since: ``CSR'' is a linear algebra concept; a graph does not have ``rows''; the same structure also represents ``CSC''; not calling it csr may avoid some of the discussions we had with linear algebra people.  This has the potential of bogging down the entire proposal.}

\section{Relationship between Graphs and Sparse Matrices}


\section{csr\_graph Graph Container}
The csr\_graph is a high-performance graph container that uses \href{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_\%28CSR\%2C_CRS_or_Yale_format\%29}{Compressed Sparse Row} format to store it's vertices, edges and associated values. Once constructed, vertices and edges cannot be added or deleted but values on vertices and edges can be modified.
\\

The following listing shows the prototype for the \tcode{csr_graph}. A fuller description, including its constructors, can be found in the \tcode{<csr_graph} header section.

Only the constructors, destructor and assignment operators for \tcode{csr_graph} are public. No other member functions or types are exposed. All other types are only accessible through the types and functions in the Graph Container Interface.

When a value type template argument (EV, VV, GV) is void then no extra overhead is incurred for it. The selection of the VId template argument impacts the inter storage requirements. If you have a small graph where the number of vertices is less than 256, and the number of edges is less than 256, then a \tcode{uint8_t} would be sufficient.

\begin{lstlisting}
template <class    EV     = void,     // Edge Value type
          class    VV     = void,     // Vertex Value type
          class    GV     = void,     // Graph Value type
          integral VId    = uint32_t, // vertex id type
          integral EIndex = uint32_t, // edge index type
          class    Alloc  = allocator<uint32_t>> // for internal containers
class csr_graph;
\end{lstlisting}

\section{csr\_partite\_graph Graph Container (In Design)}
\phil{This is experimental}

The \tcode{csr_partite_graph} extends \tcode{csr_graph} to have multiple partitions, where each partition defines a different value type for the vertex and edge. The same template arguments are used, but it also expects that the VV and EV arguments are \tcode{std::variant}, and the number of types in each is the same. The number of types in the variants define the number of partitions. The edge types apply to the outgoing edges of the vertices in the same partition. \tcode{std::monostate} can be used if no value is needed for a vertex or edge in a partition.

Example usage
\begin{lstlisting}
using VV = std::variant<int,double,bool>;
using EV = std::variant<int,int,std::monostate>; // no outgoing edges in the final partition
using G  = csr_partite_graph<EV, VV>;
G g = ...; // construct g with data
for(size_t p = 0; p < partition_size(g); ++p) {
  for(auto&& [uid,u] : partition(g,p)) {
    for(auto&& [vid,uv] : incidence(g,u)) {
       // do interesting things with uv
    }
  }
}
\end{lstlisting}
