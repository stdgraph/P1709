\chapter{Algorithms}

Our proposed set of algorithms are grouped into Tier 1, Tier 2, and Tier 3 (similar to the approach used to prioritize algorithms in \tcode{std::ranges}).

Tier 1:
\begin{itemize}
\item Shortest paths (driver interface)
\item Breadth-First search
\item Dijkstra's algorithm
\item Bellman-Ford
\item Triangle counting
\item Label propagation
\item Articulation points
\item Connected components
\item Biconnected components
\item Strongly connected components  
\item Topological sort
\item Maximal independent set
\item Page rank
\item Jaccard coefficient (?)
\item Kruskal MST
\item Prim MST
\end{itemize}

\andrew{How many should be parallelized?}

\section{Algorithm Concepts}

\andrew{Need to develop this ala CppCon 2021 talk.}

The abstraction that is used for describing and analyzing almost all graph algorithms is the adjacency list.  Naturally then implementations of graph algorithms in C++ will operate on a data structure representing an adjacency list.  And generic algorithms will be written in terms of concepts that capture the essential operations that a concrete data structure must provide in order to be used as an abstraction of an adjacency list.

Most fundamentally (as illustrated above), an adjacency list is a collection of vertices, each of which has a collection of outgoing edges.  In terms of existing C++ concepts, we can consider an adjacency list to be a range of ranges (or, more specifically, a random access range of forward ranges).  The outer range is the collection of vertices, and the inner ranges are the collections of outgoing edges.
\andrew{We should probably have that discussion soon about what we specifically mean by ``vertex''...}

\andrew{Is it better to list the concepts here or forward reference them?  Kind of a circularity.  But maybe the sequence of concepts - algorithms - concrete data types is the right one.  OTOH, std::ranges use ordering overview library-concepts-containers-algorithms.  Since a graph is a range of ranges, maybe we should follow that.}
% Additional concepts used by algorithms.

\begin{lstlisting}
template <class G, class F>
concept edge_weight_function = // e.g. weight(uv)
      copy_constructible<F> && is_arithmetic_v<invoke_result_t<F, edge_reference_t<G>>>;
\end{lstlisting}

\begin{lstlisting}
// queueableQ can represent std::queue and std::priority\_queue
template <class Q>
concept queueable = requires(Q&& q, Q::value_type value) {
  Q::value_type;
  Q::size_type;
  Q::reference;

  {q.top()};
  {q.push(value)};
  {q.pop()};
  {q.empty()};
  {q.size()};
};
\end{lstlisting}



\section{Shortest Paths}

\andrew{To keep code snippets here consistent with real working code, we use lstinputlistings to grab code from alg\_synopsis.hpp and use prototypes.cpp to compile.} \muhammad{I found that it is easier to have separate headed files for different algorithms, because the line numbers move around, you have to potentially update the whole algorithms.tex file.}




\andrew{Note that NetworkX also specifies single source single target and multiple source versions of the shortest paths algorithms.  BGL does not have these (nor NWGraph).  We should discuss whether or not to consider those and whether or not to make them Tier 1, 2, 3, or infinity.}




\subsection{Driver Interface}

\andrew{I am not sure we should have the unified interface.  We need to be more parsimonious in our interfaces.  Users can read the documentation for which algorithms to use.  And, if they are using graph algorithms, we should assume a certain level of knowledge about graph algorithms.  OTOH, it is only a handful of algorithms.}


\andrew{I am also not sure we should have ``shortest distance'' variants.  That doubles the number of functions in the interface.
      For each function we have shortest paths, s-t paths, multi-source paths, parallel = 6X variants for each base function.  If we add shortest distances, that will make 12X.  OTOH, we could consider not having s-t paths or not having multi-source paths -- which would leave 4X for each base function.  However, I think people will want s-t and multi-source.
}

{\small
      \lstinputlisting{src/shortest_paths.hpp}
}

\andrew{The variety of algorithms was inspired by networkx....  Which also had ``distance'' variants.}

\subsection{Unweighted Shortest Paths: Breadth-First Search}

\subsubsection{Breadth-First Search, Single Source, Initialization}

{\small
      \lstinputlisting{src/breadth_first_search_helpers.hpp}
}

\begin{itemdescr}
      \effects
      \begin{itemize}
            \item
                  Each \lstinline{predessors[i]} is initialized to \lstinline{i}.
            \item Each
                  \lstinline{distance[i]} is initialized to \lstinline{std::numeric_limits::max()}
                  or to \lstinline{init}.
      \end{itemize}
\end{itemdescr}


\subsubsection{Breadth-First Search, Single Source}

{\small
      \lstinputlisting{src/breadth_first_search.hpp}
}

\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{graph} is an \lstinline{adjacency_list}, which may be directed or
                  undirected.
            \item
                  \lstinline{0 <= source < num_vertices(graph)}.

            \item
                  The \lstinline{distance} range must be initialized so that
                  \lstinline{distance[i] == \lstinline{std::numeric_limits<range_value_t<D>>::max()}
                  for all \lstinline{i}
                  such that \lstinline{0 <= i < num_vertices(graph)}.  \andrew{invalid distance?}
            \item
                  The \lstinline{predecessors} range must be initialized so that
                  \lstinline{precessors[i] == i} for all \lstinline{i} such that
                  \lstinline{0 <= i <  num_vertices(graph)}.
      \end{itemize}
      \pnum\effects Compute the breadth-first path and associated distance from vertex
      \lstinline{source} to all reachable vertices in \lstinline{graph}.
      \pnum\returns
      \begin{itemize}
            \item For \lstinline{breadth_first_search} and \lstinline{breadth_first_distance},
                  if vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                  \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                  \lstinline{i}.  If vertex \lstinline{i} is not reachable from vertex
                  \lstinline{source} then \lstinline{distances[i]} will contain
                  \lstinline{std::numeric_limits<range_value_t<D>>::max()}.
            \item
                  For \lstinline{breadth_first_search} if vertex with index \lstinline{i} is reachable
                  from vertex \lstinline{source}, then \lstinline{predecessor[i]} will contain the
                  predecessor vertex of vertex \lstinline{i}.  If vertex \lstinline{i} is not reachable
                  from vertex \lstinline{source} then \lstinline{predecessors[i]} will contain
                  \lstinline{i}.
      \end{itemize}
      %
      \pnum\complexity $\mathcal{O}(|E| + |V|)$
      \pnum\throws: none. \andrew{Throw if \lstinline{source} out of range?}
\end{itemdescr}


\subsection{Weighted Shortest Paths}

\subsubsection{Dijkstra Initialization}

\andrew{I don't think the "exposition only" is necessary.}
\andrew{Actually, I don't think dijkstra\_invalid\_distance() or dijkstra\_zero() useful -- those
      need to be specified for the actual init functions.
      As free functions they don't really do anything.  Or are they meant to be CPOs? }
\andrew{Is there a run-time overhead introduced by using functions and/or CPOs for things like
      dijkstra invalid or dijkstra zero?
}
\andrew{I would like to see a use case for the dijkstra invalid and dijkstra zero functions.}

{\small
      \lstinputlisting{src/dijkstra_helpers.hpp}
}

\begin{itemdescr}
      \pnum
      \effects:
      \begin{itemize}
            \item
                  Each \lstinline{predessors[i]} is initialized to \lstinline{i}.
            \item Each
                  \lstinline{distance[i]} is initialized to \lstinline{std::numeric_limits::max()}
                  or to \lstinline{init}.
      \end{itemize}
\end{itemdescr}


\subsubsection{Dijkstra Single Source Shortest Paths}

{\small
      \lstinputlisting{src/dijkstra.hpp}
}

\begin{itemdescr}
      \item\preconditions
      \begin{itemize}
            \item
                  \lstinline{graph} is an \lstinline{adjacency_list}, which may be directed or
                  undirected.
            \item
                  \lstinline{0 <= source < num_vertices(graph)}.
                  \pnum
                  The \lstinline{distance} range must be initialized so that
                  \lstinline{distance[i] == \lstinline{std::numeric_limits<range_value_t<D>>::max()}
                  for all \lstinline{i}
                  such that \lstinline{0 <= i < num_vertices(graph)}.  \andrew{invalid distance?}
            \item
                  The \lstinline{predecessors} range must be initialized so that
                  \lstinline{precessors[i] == i} for all \lstinline{i} such that
                  \lstinline{0 <= i <  num_vertices(graph)}.
      \end{itemize}
      \pnum\requires:
      \begin{itemize}
            \item
                  The return type of weight function \lstinline{w} must be able to
                  be combined with the distance type \lstinline{D}.
            \item
                  The argument type for the weight
                  function \lstinline{w} must be convertible from the edge type.
            \item
                  The weight function \lstinline{w} must return a non-negative value (that is
                  a value \lstinline{x} such that \lstinline{dijkstra_zero() <= x},
                  for any edge in \lstinline{graph}.
      \end{itemize}
      \pnum\effects
      Compute the shortest path and associated distance from vertex
      \lstinline{source} to all reachable vertices in \lstinline{graph}.
      \pnum\returns
      \begin{itemize}
            \item
                  For \lstinline{dijkstra_shortest_paths} and \lstinline{dijkstra_shortest_distances},
                  if vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                  \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                  \lstinline{i}.  If vertex \lstinline{i} is not reachable from vertex
                  \lstinline{source} then \lstinline{distances[i]} will contain
                  \lstinline{std::numeric_limits<range_value_t<D>>::max()}.
            \item
                  For \lstinline{dijkstra_shortest_paths} if vertex with index \lstinline{i} is reachable
                  from vertex \lstinline{source}, then \lstinline{predecessor[i]} will contain the
                  predecessor vertex of vertex \lstinline{i}.  If vertex \lstinline{i} is not reachable
                  from vertex \lstinline{source} then \lstinline{predecessors[i]} will contain
                  \lstinline{i}.
      \end{itemize}
      %
      \pnum\complexity $\mathcal{O}((|E| + |V|)\log{|V|})$.  (Note: complexity may be
            $\mathcal{O}(|E| + |V|\log{|V|)}$ for certain implementations.)
      \pnum\throws none. \andrew{Throw if \lstinline{source} out of range?}
\end{itemdescr}


\subsubsection{Bellman-Ford Single Source Shortest Paths}

{\small
      \lstinputlisting{src/bellman_ford.hpp}
}

\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{graph} is an \lstinline{adjacency_list}, which may be directed or
                  undirected.
            \item
                  \lstinline{0 <= source < num_vertices(graph)}.
            \item
                  The \lstinline{distance} range must be initialized so that
                  \lstinline{distance[i] ==  \lstinline{std::numeric_limits<range_value_t<D>>::max()}
                  for all \lstinline{i}
                  such that \lstinline{0 <= i < num_vertices(graph)}.  \andrew{invalid distance?}
            \item
                  The \lstinline{predecessors} range must be initialized so that
                  \lstinline{precessors[i] == i} for all \lstinline{i} such that
                  \lstinline{0 <= i < num_vertices(graph)}.
            \item
                  The return type of weight function \lstinline{w} must be able to
                  be combined with the distance type \lstinline{D}.  The argument type for the weight
                  function \lstinline{w} must be convertible from the edge type.
      \end{itemize}
      \pnum
      \effects Compute the shortest path and associated distance from vertex
      \lstinline{source} to all reachable vertices in \lstinline{graph}.
      \pnum\returns
      \begin{itemize}
            \item For \lstinline{bellman_ford_shortest_paths} and \lstinline{bellman_ford_shortest_distances},
                  if vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                  \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                  \lstinline{i}.  If vertex \lstinline{i} is not reachable from vertex
                  \lstinline{source} then \lstinline{distances[i]} will contain
                  \lstinline{std::numeric_limits<range_value_t<D>>::max()}.
            \item
                  For \lstinline{bellman_ford_shortest_paths} if vertex with index \lstinline{i} is reachable
                  from vertex \lstinline{source}, then \lstinline{predecessor[i]} will contain the
                  predecessor vertex of vertex \lstinline{i}.  If vertex \lstinline{i} is not reachable
                  from vertex \lstinline{source} then \lstinline{predecessors[i]} will contain
                  \lstinline{i}.
      \end{itemize}
      %
      \pnum\complexity $\mathcal{O}(|E| \cdot |V|)$ \andrew{This really is atrocious.  Suitable only for really small graphs.}
      \pnum\throws none. \andrew{Throw if \lstinline{source} out of range?}
      \pnum\remarks:  Unlike Dijkstra's algorithm, Bellman-Ford allows negative edge weights.
\end{itemdescr}


\section{Clustering}
\subsection{Triangle Counting}

\section{Communities}
\subsection{Label Propagation}

\section{Components}
\subsection{Articulation Points}
{\small
     \lstinputlisting[firstline=25,lastline=30]{src/connected_components.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
              \lstinline{g} is an \lstinline{adjacency_list}.
            \item
              Output iterator \lstinline{cut_vertices} can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
            Output iterator \lstinline{cut_vertices} contains articulation point vertices, those which removed increase the number of components of \lstinline{g}.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|+|V|)$
\end{itemdescr}

\subsection{BiConnected Components}
{\small
     \lstinputlisting[firstline=34,lastline=40]{src/connected_components.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
              \lstinline{g} is an \lstinline{adjacency_list}.
            \item
              \lstinline{components} is a container of containers. The inner container stores vertex ids.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
            \lstinline{components} contains groups of biconnected components.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|+|V|)$
\end{itemdescr}

\subsection{Connected Components}
{\small
     \lstinputlisting[firstline=45,lastline=49]{src/connected_components.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{g} is an \lstinline{adjacency_list}.
            \item
                  Size of \lstinline{component} is greater than or equal to \lstinline{num_vertices(g)}.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
                  \lstinline{component[v]} is the connected component id of \lstinline{v}.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|+|V|)$
\end{itemdescr}

\subsection{Strongly Connected Components}
\subsubsection{Kosaraju's SCC}
{\small
      \lstinputlisting[firstline=4, lastline=11]{src/connected_components.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{g} is an \lstinline{adjacency_list}, which is directed.
            \item
                  \lstinline{g_t} is an \lstinline{adjacency_list}, which is directed
            \item
                  \lstinline{g_t} is the transpose of \lstinline{g}. Edge \lstinline{uv} in \lstinline{g} implies edge \lstinline{vu} in \lstinline{g_t}. \lstinline{num_vertices(g)} equals \lstinline{num_vertices(g_t)}.
            \item
                  Size of \lstinline{component} is greater than or equal to \lstinline{num_vertices(g)}.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
                  \lstinline{component[v]} is the strongly connected component id of \lstinline{v}.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|+|V|)$
\end{itemdescr}

\subsubsection{Tarjan's SCC}
{\small
      \lstinputlisting[firstline=16,lastline=20]{src/connected_components.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{g} is an \lstinline{adjacency_list}, which is directed.
            \item
                  Size of \lstinline{component} is greater than or equal to \lstinline{num_vertices(g)}.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
                  \lstinline{component[v]} is the strongly connected component id of \lstinline{v}.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|+|V|)$
\end{itemdescr}

\section{Directed Acyclic Graphs}
\subsection{Topological Sort}

\section{Maximal Independent Set}
\subsection{Maximal Independent Set}

{\small
      \lstinputlisting{src/mis.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{graph} is an \lstinline{adjacency_list}, which is undirected.
            \item
                  \lstinline{0 <= seed < num_vertices(graph)}.
            \item
                  \lstinline{mis} output iterator can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
      \end{itemize}
      \pnum\effects Output iterator \lstinline{mis} contains maximal independent set of vertices containing \lstinline{seed}, which is a subset of \lstinline{vertices(graph)}.
      \pnum\complexity $\mathcal{O}(|E|)$
\end{itemdescr}

\section{Link Analysis}
\subsection{Page Rank}
\andrew{Tier 1 or Tier 2?} \muhammad{Tier 1?}

{\small
      \lstinputlisting{src/pagerank.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{graph} is an \lstinline{adjacency_list}, which can be directed or undirected.
            \item
                  The \lstinline{scores} range must be initialized so that
                  \lstinline{scores[i] == 0}
                  for all \lstinline{i}
                  such that \lstinline{0 <= i < num_vertices(graph)}.
            \item
                  \lstinline{damping_factor} for the page rank algorithm, default is set to \lstinline{0.85}.
            \item
                  \lstinline{threshold} for checking convergence, default is set to \lstinline{1e-4}. \muhammad{Maybe change this to type limit?}
            \item
                  \lstinline{max_iterations} is the number of maximum iterations if the algorithm does not converge. Default is set to \lstinline{std::numeric_limits<unsigned int>::max()}.
            \item
                  \lstinline{weight_fn} The edge value function (default returns 1 for each edge value.)
      \end{itemize}
      \pnum\effects Output iterator \lstinline{scores} contains the page rank of each vertex in the graph, accessible through \lstinline{scores[uid]}, where uid is the \lstinline{vertex_id}. The caller must assure \lstinline{size(scores) >= size(vertices(g))}.
      \pnum\complexity $\mathcal{O}(|E \times k|)$ where $k$ is the number of iterations required to converge (dependent on the data).
\end{itemdescr}


\subsection{Jaccard Coefficient}
\andrew{Tier 1 or Tier 2?}


\section{Minimum Spanning Tree}
\andrew{Simplified ``driver'' for these also?}

\subsection{Kruskal Minimum Spanning Tree}

{\small
      \lstinputlisting[firstline=4,lastline=8]{src/mst.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{e} is an \lstinline{edgelist}.
            \item
                  \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{edge_value_t<EL>} which returns a bool.
      \end{itemize}
      \pnum\effects Edgelist \lstinline{t} contains edges representing a spanning tree or forest, which minimize the comparison operator. When \lstinline{compare} is \lstinline{<}, \lstinline{t} represents a minimum weight spanning tree.
      \pnum\complexity $\mathcal{O}(|E|)$
\end{itemdescr}

\subsection{Prim Minimum Spanning Tree}

{\small
      \lstinputlisting[firstline=13,lastline=29]{src/mst.hpp}
}
\begin{itemdescr}
      \pnum\preconditions
      \begin{itemize}
            \item
                  \lstinline{g} is an \lstinline{adjacency_list}, which is undirected.
            \item
                  \lstinline{0 <= seed < num_vertices(g)}.
            \item
                  Size of \lstinline{weight} and \lstinline{predecessor} is greater than or equal to \lstinline{num_vertices(g)}.
            \item
                  \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{edge_value_t<G>} which returns a bool.
      \end{itemize}
      \pnum\effects
      \begin{itemize}
            \item
                  \lstinline{predecessor[v]} is the parent vertex of \lstinline{v} in a tree rooted at \lstinline{seed} and \lstinline{weight[v]} is the value of the edge between \lstinline{v} and \lstinline{predecessor[v]} in the tree. When \lstinline{compare} is \lstinline{<} and \lstinline{init_dist==+inf}, \lstinline{predecessor} represents a minimum weight spanning tree.
            \item
                  If \lstinline{predecessor} and \lstinline{weight} are not initialized by user, and the graph is not fully connected, \lstinline{predecessor[v]} and \lstinline{weight[v]} will be undefined for vertices not in the same connected component as \lstinline{seed}.
      \end{itemize}

      \pnum\complexity $\mathcal{O}(|E|log|V|)$
\end{itemdescr}

\section{Operators}
\subsection{Degree}

\subsection{Join}

\subsection{Relabel}

\subsection{Sort}

\andrew{Need to be able to sort edge lists along source or target column as well as to sort lists of neighbors in an adjacency list.  The former is necessary for efficiently building CSR from an edge list.  The second is necessary for preconditions on various algorithms.}
\subsection{Transpose}





\andrew{I've tagged the algorithms below as Tier 2 or Tier 3 -- denoting whether they should be done right now or done later or done much later.}

\andrew{I've used NetworkX as inspiration for organization.  Oddly, NetworkX only has DFS as an adaptor (view).}


\chapter{Other Algorithms}

Additional algorithms that were considered but not included in this proposal are identified in Table \ref{tab:other_algorithms}. 
It is assumed that future proposals will include them, with a recommendation of each Tier being in its own proposal.
Tier X algorithms are variations of shortest paths algorithms that complement the Single Source, Multiple Target algorithms 
in this proposal.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l|l|l}
\hline
    \textbf{Tier 2} & \textbf{Tier 3} & \textbf{Tier X} \\
\hline
    All Pairs Shortest Paths & Jones Plassman & Single Source, Single Target: Shortest Paths\\
    Floyd-Warshall & Cores: k-cores & Single Source, Single Target: BFS \\
    Johnson & Cores: k-truss & Single Source, Single Target: Dijkstra \\
    Centrality: Betweenness Centrality & Subgraph Isomorphism & Single Source, Single Target: Bellman-Ford \\
    Coloring: Greedy & & Single Source, Single Target: Delta Stepping \\
    Communities: Louvain & &  \\
    Connectivity: Minimum Cuts & & Multiple Source: Shortest Paths \\
    Transitive Closure & & Multiple Source: BFS \\
    Flows: Edmunds Karp & & Multiple Source: Dijkstra \\
    Flows: Push Relabel & & Multiple Source: Bellman-Ford \\
    Flows: Boykov Kolmogorov & & Multiple Source: Delta Stepping \\
    & &  \\
    & & Multiple Source, Single Target: Shortest Paths \\
    & & Multiple Source, Single Target: BFS \\
    & & Multiple Source, Single Target: Dijkstra \\
    & & Multiple Source, Single Target: Bellman-Ford \\
    & & Multiple Source, Single Target: Delta Stepping \\
\hline
\end{tabular}}
\caption{Other Algorithms}
\label{tab:other_algorithms}
\end{center}
\end{table}


\andrew{All Pairs: Tier 2?  People bring this up alot -- but it is very expensive in terms of computation and memory.}

% Floyd-Warshall $\mathcal{O}(N^2)$}
% Johnson $\mathcal{O}(N^2)$}



\begin{comment}

%Algorithms with [TBD] are candidates to consider but having been decided for being in the paper
%We are targeting the paper to be under 50pp
All algorithms are customization points.

\phil{Algorithms marked [TBD] are provisional and may be moved to a separate proposal to keep the size of this proposal manageable}

\subsection{Dijkstra's Shortest Paths and Shortest Distances}
Dijkstra's algorithm \cite{REF_} is a single-source, shortest paths algorithm for non-negative weights. It finds the shortest paths
and their weighted distances to all vertices connected to a single seed vertex.

\begin{lstlisting}
template <adjacency_list G, class DistanceValue>
auto dijkstra_invalid_distance() {
  return numeric_limits<DistanceValue>::max(); // exposition only
}

template <adjacency_list              G,
          ranges::random_access_range Distance,
          ranges::random_access_range Predecessor,
          class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
          queueable Q = 
              priority_queue<
                  weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                  vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                  greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
requires ranges::random_access_range<vertex_range_t<G>> &&                  //
      integral<vertex_id_t<G>> &&                                           //
      is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
      convertible_to<vertex_id_t<G>, ranges::range_value_t<Predecessor>> && //
      edge_weight_function<G, EVF>
constexpr void dijkstra_shortest_paths(
      G&&            g,           // graph
      vertex_id_t<G> seed,        // starting vertex_id
      Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
      Predecessor&   predecessor, // out: predecessor[uid] of vertex_id uid in path
      EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                         { return ranges::range_value_t<Distance>(1); },
      Q              q = Q()
      );
\end{lstlisting}

\begin{table}[h!]
      %\begin{center}
      %\resizebox{\textwidth}{!}
      {\begin{tabular}{l l}
                  \hline
                  \textit{Complexity}     & O(V log(V)).                                                                                                                                                  \\
                                          & Additional time will be required to pre-extend  or initialize the \tcode{distance} range by the caller.                                                       \\
                                          & Additional time may also be required to pre-extend \tcode{predecessor}.                                                                                       \\
                  \andrew{O((|E| + |V|)log(|V|) or O(|E| + |V|log(|V|).  Initializing distance and predecessor are O(|V|) so don't change the complexity.}
                  \hline
                  \textit{Constraints}    & Values returned by \tcode{weight_fn} must be non-negative.                                                                                                    \\
                  \hline
                  \textit{Preconditions}  & \tcode{seed >= 0                                                                                                               &  & seed < size(vertices(g))} \\
                                          & \tcode{size(distance) >= size(vertices(g))}; caller must pre-extend with \tcode{dikstra_invalid_distance()}                                                   \\
                                          & \tcode{size(predecessor) >= size(vertices(g))}; caller must pre-extend                                                                                        \\
                                          & \tcode{distance[i] = dijkstra_invalid_distance()} for \tcode{i < size(vertices(g))}                                                                           \\
                  \hline
                  \textit{Postconditions} & \tcode{distance[seed] == 0}                                                                                                                                   \\
                                          & \tcode{predecessor[seed] == seed}.                                                                                                                            \\
                  \hline
                  \textit{\effects}       & \tcode{distance[uid]} will be the shortest, weighted distance of vertex\_id \tcode{uid} from \tcode{seed}.                                                    \\
                                          & If \tcode{uid} is not connected to \tcode{seed} by any edges then it will have a value of \tcode{dijkstra_invalid_distance()}.                                \\
                                          &                                                                                                                                                               \\
                                          & \tcode{predecessor[uid]} will have the preceding vertex\_id of \tcode{uid} in the weighted shortest path to \tcode{seed}                                      \\
                                          & when \tcode{distance[uid] != dijkstra_invalid_distance()}.                                                                                                    \\
                  \hline
            \end{tabular}}
      %\caption{\tcode{incidence} View Functions}
      %\label{tab:incidence}
      %\end{center}
\end{table}

\phil{Describe the pros and cons of different kinds of queues} \\

\andrew{Consider putting the queue template parameter on BFS and passing BFS as a parameter to Dijkstra. Kevin will think about it.} \\

The default weight function \tcode{weight_fn} returns a value of 1. When that is used, \tcode{distance[uid]} will have the shortest number of edges
between vertex \tcode{uid} and vertex \tcode{seed}. The distance from \tcode{seed} to itself is zero.

If the caller wishes to use a different queue other than \tcode{priority_queue}, the queue will need to have elements of \tcode{weighted_vertex}
which is used internally by the algorithm.
\begin{lstlisting}
template <class G, class W>
requires is_default_constructible_v<vertex_id_t<G>> && is_default_constructible_v<W>
struct weighted_vertex {
  vertex_id_t<G> vertex_id = vertex_id_t<G>();
  W              weight    = W();
  constexpr auto operator<=>(const weighted_vertex&) const noexcept; // compare vertex_id
};
\end{lstlisting}

The \tcode{dijkstra_shortest_distances} function is the same as \tcode{dijkstra_shortest_paths} except that it doesn't include
the \tcode{predecessor} parameter.
\begin{lstlisting}
template <adjacency_list              G,
          ranges::random_access_range Distance,
          class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
          queueable Q = 
              priority_queue<
                  weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                  vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                  greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
requires ranges::random_access_range<vertex_range_t<G>> &&                  //
      integral<vertex_id_t<G>> &&                                           //
      is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
      edge_weight_function<G, EVF>
constexpr void dijkstra_shortest_distances(
      G&&            g,           // graph
      vertex_id_t<G> seed,        // starting vertex_id
      Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
      EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                         { return ranges::range_value_t<Distance>(1); },
      Q              q = Q()
      );
\end{lstlisting}

\subsection{[TBD] Delta Stepping Shortest Paths}
The  algorithm \cite{REF_} ...

\subsection{Bellman-Ford Shortest Paths}
The Bellman-Ford algorithm \cite{REF_} ...

\subsection{[TBD] Shortest Paths}
(Overloads to select appropriate algorithm based on inputs)

\subsection{Connected Components}
Connected components \cite{REF_} ...

\subsection{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\subsection{Biconnected Components}
Biconnected components \cite{REF_} ...

\subsection{Articulation Points}
Articulation points \cite{REF_} ...

\subsection{Minimum Spanning Tree}
Minimum Spanning Tree \cite{REF_} ...

\subsection{[TBD] Page Rank}
\subsection{[TBD] Betweenness Centrality}
\subsection{[TBD] Triangle Count}
\subsection{[TBD] Subgraph Isomorphism}
\subsection{[TBD] Kruskell Minimum Spanning Tree}
\subsection{[TBD] Prim Minimum Spanning Tree}
\subsection{[TBD] Louvain (Community Detection)}
\subsection{[TBD] Label propagation (Community Detection)}

\end{comment}
