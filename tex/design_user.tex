\section{Design - User Side}
\subsection{Algorithm Concepts}
Additional concepts used by algorithms.
\begin{lstlisting}
template <class G, class F>
concept edge_weight_function = // e.g. weight(uv)
      copy_constructible<F> && is_arithmetic_v<invoke_result_t<F, edge_reference_t<G>>>;
\end{lstlisting}

\begin{lstlisting}
// queueable<Q> can represent std::queue and std::priority_queue
template <class Q>
concept queueable = requires(Q&& q, Q::value_type value) {
  Q::value_type;
  Q::size_type;
  Q::reference;

  {q.top()};
  {q.push(value)};
  {q.pop()};
  {q.empty()};
  {q.size()};
};
\end{lstlisting}


\subsection{Algorithms}
%Algorithms with [TBD] are candidates to consider but having been decided for being in the paper
%We are targeting the paper to be under 50pp
All algorithms are customization points.

\phil{Algorithms marked [TBD] are provisional and may be moved to a separate proposal to keep the size of this proposal manageable}

\subsubsection{Dijkstra's Shortest Paths and Shortest Distances}
Dijkstra's algorithm \cite{REF_} is a single-source, shortest paths algorithm for non-negative weights. It finds the shortest paths 
and their weighted distances to all vertices connected to a single seed vertex.

\begin{lstlisting}
template <adjacency_list G, class DistanceValue>
auto dijkstra_invalid_distance() {
  return numeric_limits<DistanceValue>::max(); // exposition only
}

template <adjacency_list              G,
          ranges::random_access_range Distance,
          ranges::random_access_range Predecessor,
          class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
          queueable Q = 
              priority_queue<
                  weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                  vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                  greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
requires ranges::random_access_range<vertex_range_t<G>> &&                  //
      integral<vertex_id_t<G>> &&                                           //
      is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
      convertible_to<vertex_id_t<G>, ranges::range_value_t<Predecessor>> && //
      edge_weight_function<G, EVF>
constexpr void dijkstra_shortest_paths(
      G&&            g,           // graph
      vertex_id_t<G> seed,        // starting vertex_id
      Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
      Predecessor&   predecessor, // out: predecessor[uid] of vertex_id uid in path
      EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                         { return ranges::range_value_t<Distance>(1); },
      Q              q = Q()
      );
\end{lstlisting}

\begin{table}[h!]
%\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textit{Complexity} & O(V log(V)). \\
                                & Additional time will be required to pre-extend  or initialize the \tcode{distance} range by the caller. \\
                                & Additional time may also be required to pre-extend \tcode{predecessor}. \\
\hline
    \textit{Constraints} &  Values returned by \tcode{weight_fn} must be non-negative. \\
\hline
    \textit{Preconditions} &  \tcode{seed >= 0 && seed < size(vertices(g))} \\
                                   &  \tcode{size(distance) >= size(vertices(g))}; caller must pre-extend with \tcode{dikstra_invalid_distance()} \\
                                   &  \tcode{size(predecessor) >= size(vertices(g))}; caller must pre-extend \\
                                   & \tcode{distance[i] = dijkstra_invalid_distance()} for \tcode{i < size(vertices(g))} \\
\hline
    \textit{Postconditions} &  \tcode{distance[seed] == 0} \\
                                     & \tcode{predecessor[seed] == seed}. \\
\hline
    \textit{Effects} & \tcode{distance[uid]} will be the shortest, weighted distance of vertex\_id \tcode{uid} from \tcode{seed}. \\
    & If \tcode{uid} is not connected to \tcode{seed} by any edges then it will have a value of \tcode{dijkstra_invalid_distance()}. \\
    & \\
    & \tcode{predecessor[uid]} will have the preceding vertex\_id of \tcode{uid} in the weighted shortest path to \tcode{seed} \\
    & when \tcode{distance[uid] != dijkstra_invalid_distance()}. \\
\hline
\end{tabular}}
%\caption{\tcode{incidence} View Functions}
%\label{tab:incidence}
%\end{center}
\end{table}

\phil{Describe the pros and cons of different kinds of queues} \\

\andrew{Consider putting the queue template parameter on BFS and passing BFS as a parameter to Dijkstra. Kevin will think about it.} \\

The default weight function \tcode{weight_fn} returns a value of 1. When that is used, \tcode{distance[uid]} will have the shortest number of edges 
between vertex \tcode{uid} and vertex \tcode{seed}. The distance from \tcode{seed} to itself is zero.

If the caller wishes to use a different queue other than \tcode{priority_queue}, the queue will need to have elements of \tcode{weighted_vertex}
which is used internally by the algorithm.
\begin{lstlisting}
template <class G, class W>
requires is_default_constructible_v<vertex_id_t<G>> && is_default_constructible_v<W>
struct weighted_vertex {
  vertex_id_t<G> vertex_id = vertex_id_t<G>();
  W              weight    = W();
  constexpr auto operator<=>(const weighted_vertex&) const noexcept; // compare vertex_id
};
\end{lstlisting}

The \tcode{dijkstra_shortest_distances} function is the same as \tcode{dijkstra_shortest_paths} except that it doesn't include
the \tcode{predecessor} parameter.
\begin{lstlisting}
template <adjacency_list              G,
          ranges::random_access_range Distance,
          class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
          queueable Q = 
              priority_queue<
                  weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                  vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                  greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
requires ranges::random_access_range<vertex_range_t<G>> &&                  //
      integral<vertex_id_t<G>> &&                                           //
      is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
      edge_weight_function<G, EVF>
constexpr void dijkstra_shortest_distances(
      G&&            g,           // graph
      vertex_id_t<G> seed,        // starting vertex_id
      Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
      EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                         { return ranges::range_value_t<Distance>(1); },
      Q              q = Q()
      );
\end{lstlisting}

\subsubsection{[TBD] Delta Stepping Shortest Paths}
The  algorithm \cite{REF_} ...

\subsubsection{Bellman-Ford Shortest Paths}
The Bellman-Ford algorithm \cite{REF_} ...

\subsubsection{[TBD] Shortest Paths}
(Overloads to select appropriate algorithm based on inputs)

\subsubsection{Connected Components}
Connected components \cite{REF_} ...

\subsubsection{Strongly Connected Components}
Strongly connected components \cite{REF_} ...

\subsubsection{Biconnected Components}
Biconnected components \cite{REF_} ...

\subsubsection{Articulation Points}
Articulation points \cite{REF_} ...

\subsubsection{Minimum Spanning Tree}
Minimum Spanning Tree \cite{REF_} ...

\subsubsection{[TBD] Page Rank}
\subsubsection{[TBD] Betweenness Centrality}
\subsubsection{[TBD] Triangle Count}
\subsubsection{[TBD] Subgraph Isomorphism}
\subsubsection{[TBD] Kruskell Minimum Spanning Tree}
\subsubsection{[TBD] Prim Minimum Spanning Tree}
\subsubsection{[TBD] Louvain (Community Detection)}
\subsubsection{[TBD] Label propagation (Community Detection)}

\subsection{Views}
The views in this section provide comman ways that algorithms use to traverse graphs. They are a simple as iterating through the set of vertices, or more complex ways such as depth-first search and breadth-first search. The also provide a consistent and reliable way to access related elements using the View Return Types, and guaranteeing expected values, such as that the target is really the target on unordered edges.

\subsubsection{Return Types}
Views return one of the types in this section, providing a consistent set of values. They are templated so that the view can adjust the actual values returned to be appropriate for its use. The following examples show the general design and how it's used. While it focuses on vertexlist to iterate over all vertices, it applies to all view functions.

\begin{lstlisting}
// the type of uu is vertex_view<vertex_id_t<G>, vertex_reference_t<G>, void>
for(auto&& uu : vertexlist(g)) {
  vertex_id<G>          id = uu.id;
  vertex_reference_t<G> u  = uu.vertex;
  // ... do something interesting
}
\end{lstlisting}

Structured bindings make it simpler.
\begin{lstlisting}
for(auto&& [id, u] : vertexlist(g)) {
  // ... do something interesting
}
\end{lstlisting}

A function object can also be passed to return a value from the vertex. In this case, \tcode{vertexlist(g)} returns \tcode{vertex_view<vertex_id_t<G>, vertex_reference_t<G>, decltype(vvf(u))>}.
\begin{lstlisting}
// the type returned by vertexlist is 
// vertex_view<vertex_id_t<G>, 
//             vertex_reference_t<G>, 
//             decltype(vvf(vertex_reference_t<G>))>
auto vvf = [&g](vertex_reference_t<G> u) { return vertex_value(g,u); };
for(auto&& [id, u, value] : vertexlist(g, vvf)) {
  // ... do something interesting
}
\end{lstlisting}

\paragraph{\tcode{struct vertex_view<Vid, V, VV>}}\label{vertex-view}\mbox{} \\
\tcode{vertex_view} is used to return vertex information. It is used by \tcode{vertexlist(g)}, \tcode{vertices_breadth_first_search(g,u)}, \tcode{vertices_depth_first_search(g,u)} and others. The \tcode{id} member always exists.

\begin{lstlisting}
template <class VId, class V, class VV>
struct vertex_view {
  VId id;     // vertex_id_t<G>, always exists
  V   vertex; // vertex_reference_t<t>
  VV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{V}=void or \tcode{VV}=void to suppress the existance of their associated member variables, giving the following valid combinations in Table \ref{tab:vertex-view} . For instance, the second entry, \tcode{vertex_view<VId, V>} has two members \tcode{\{VId id; V vertex;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{3}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & vertex & value \\
\hline
    \tcode{vertex_view<VId, V, VV>} & \tcode{id} & \tcode{vertex} & \tcode{value} \\
    \tcode{vertex_view<VId, V, void>} & \tcode{id} & \tcode{vertex} & \\
    \tcode{vertex_view<VId, void, VV>} & \tcode{id} & & \tcode{value} \\
    \tcode{vertex_view<VId, void, void>} & \tcode{id} & & \\
\hline
\end{tabular}}
\caption{\tcode{vertex_view} Members}
\label{tab:vertex-view}
\end{center}
\end{table}

A useful type alias for copying vertex values (excluding the vertex reference) is also available.
\begin{lstlisting}
template <class VId, class VV>
using copyable_vertex_t = vertex_view<VId, void, VV>; // {id, value}
\end{lstlisting}

\paragraph{\tcode{struct edge_view<VId, Sourced, E, EV>}}\label{edge-view}\mbox{} \\
\tcode{edge_view} is used to return edge information. It is used by \tcode{incidence(g,u)}, \tcode{edgelist(g)}, \tcode{edges_breadth_first_search(g,u)}, \tcode{edges_depth_first_search(g,u)} and others. When \tcode{Sourced}=true, the \tcode{source_id} member is included with type \tcode{VId}. The \tcode{target_id} member always exists.

\begin{lstlisting}
template <class VId, bool Sourced, class E, class EV>
struct edge_view {
  VId source_id; // vertex_id_t<G>, exists when SourceId==true
  VId target_id; // vertex_id_t<G>, always exists
  E   edge;      // edge_reference_t<G>
  EV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{Sourced}=true\(|\)false, \tcode{E}=void or \tcode{EV}=void to suppress the existance of the associated member variables, giving the following valid combinations in Table \ref{tab:edge-view} . For instance, the second entry, \tcode{edge_view<VId,true,E>} has three members \tcode{\{VId source_id; VId target_id; E edge;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & edge & value \\
\hline
    \tcode{edge_view<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_view<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_view<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_view<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{edge_view<VId, false, E, EV>} & & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_view<VId, false, E, void>} & & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_view<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_view<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{edge_view} Members}
\label{tab:edge-view}
\end{center}
\end{table}

A useful type alias for copying edge values (excluding the edge reference) is also available.
\begin{lstlisting}
template <class VId, class EV>
using copyable_edge_t = edge_view<VId, true, void, EV>; // {source_id, target_id [, value]}
\end{lstlisting}


\paragraph{\tcode{struct neighbor_view<VId, Sourced, V, VV>}}\label{neighbor-view}\mbox{} \\
\tcode{neighbor_view} is used to return information for a neighbor vertex, through an edge. It is used by \tcode{neighbors(g,u)}. When \tcode{Sourced}=true, the \tcode{source_id} member is included with type \tcode{VId}. The \tcode{target_id} member always exists.

\begin{lstlisting}
template <class VId, bool Sourced, class V, class VV>
struct neighbor_view {
  VId source_id;  // vertex_id_t<G>
  VId target_id;  // vertex_id_t<G>, always exists
  V   target;     // vertex_reference_t<G>
  VV  value;
};
\end{lstlisting}

Specializations are defined with \tcode{Sourced}=true\(|\)false, \tcode{E}=void or \tcode{EV}=void to suppress the existance of the associated member variables, giving the following valid combinations in Table \ref{tab:neighbor-view} . For instance, the second entry, \tcode{neighbor_view<VId,true,E>} has three members \tcode{\{VId source_id; VId target_id; V target;\}}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
\hline
    \tcode{neighbor_view<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_view<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_view<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_view<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{neighbor_view<VId, false, E, EV>} & & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_view<VId, false, E, void>} & & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_view<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_view<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{neighbor_view} Members}
\label{tab:neighbor-view}
\end{center}
\end{table}

\subsubsection{Common Types and Functions for ``Search'' }
The depth\_first\_search, breadth\_first\_search, and toplogical\_sort searches there are a number of common types and functions that apply to them. 

Here are the types and functions for cancelling a search, getting the current depth of the search, and active elements in the search (e.g. number of vertices in a stack or queue).
\begin{lstlisting}
// enum used to define how to cancel a search
enum struct cancel_search : int8_t { 
  continue_search, // no change (ignored)
  cancel_branch,   // stops searching from current vertex
  cancel_all       // stops searching and dfs will be at end()
};

// stop searching from current vertex
template<class S)
void cancel(S search, cancel_search);

// Returns distance from the seed vertex to the current vertex, 
// or to the target vertex for edge views
template<class S>
auto depth(S search) -> integral;

// Returns number of pending vertices to process
template<class S>
auto size(S search) -> integral; 
\end{lstlisting}

Of particular note, \tcode{size(dfs)} is typically the same as \tcode{depth(dfs)} and is simple to calculate. breadth\_first\_search requires extra bookkeeping to evaluate \tcode{depth(bfs)} and returns a different value than \tcode{size(bfs)}.

The following example shows how the functions  could be used, using \tcode{dfs} for one of the depth\_first\_search views. The same functions can be used for all all search views.
\begin{lstlisting}
auto&& g = ...; // graph
auto&& dfs = vertices_depth_first_search(g,0); // start with vertex_id=0
for(auto&& [vid,v] : dfs) {
  // No need to search deeper?
  if(depth(dfs) > 3) {
    cancel(dfs,cancel_search::cancel_branch);
    continue;
  }
  
  if(size(dfs) > 1000) {
    std::cout << "Big depth of " << size(dfs) << '\n';
  }
  
  // do useful things
}

\end{lstlisting}

\subsubsection{vertexlist Views}
\
\tcode{vertexlist} views iterate over a range of vertices, returning a \tcode{vertex_view} on each iteration. 
Table \ref{tab:vertexlist} shows the vertexlist functions overloads and their return values. \tcode{first} and \tcode{last} are vertex iterators.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,u] : vertexlist(g))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,first,last))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,first,last,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,vr))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vr,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{vertexlist} View Functions}
\label{tab:vertexlist}
\end{center}
\end{table}

\subsubsection{incidence Views}
\tcode{incidence} views iterate over a range of adjacent edges of a vertex, returning a \tcode{edge_view} on each iteration. 
Table \ref{tab:incidence} shows the \tcode{incidence} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling an \tcode{incidence} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : incidence(g,u))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : incidence(g,u,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{incidence} View Functions}
\label{tab:incidence}
\end{center}
\end{table}

\subsubsection{neighbors Views}
\tcode{neighbors} views iterate over a range of edges for a vertex, returning a \tcode{vertex_view} of each neighboring target vertex on each iteration. 
Table \ref{tab:neighbors} shows the \tcode{neighbors} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling a \tcode{neighbors} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : neighbors(g,u))} & \tcode{neighbor_view<VId,false,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : neighbors(g,u,vvf))} & \tcode{neighbor_view<VId,false,V,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{neighbors} View Functions}
\label{tab:neighbors}
\end{center}
\end{table}

\subsubsection{edgelist Views}
\tcode{edgelist} views iterate over all edges for all vertices, returning a \tcode{edge_view} on each iteration. 
Table \ref{tab:edgelist} shows the \tcode{edgelist} function overloads and their return values. 

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : edgelist(g))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : edgelist(g,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{edgelist} View Functions}
\label{tab:edgelist}
\end{center}
\end{table}

\subsubsection{depth\_first\_search Views}
depth\_first\_search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:dfs} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_depth_first_search(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_depth_first_search(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_depth_first_search(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_depth_first_search(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_depth_first_search(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_depth_first_search(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{depth\_first\_search View Functions}
\label{tab:dfs}
\end{center}
\end{table}

\subsubsection{breadth\_first\_search Views}
breadth\_first\_search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:bfs} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_breadth_first_search(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_breadth_first_search(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_breadth_first_search(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_breadth_first_search(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_breadth_first_search(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_breadth_first_search(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{breadth\_first\_search View Functions}
\label{tab:bfs}
\end{center}
\end{table}

\subsubsection{topological\_sort Views}
topological\_sort views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_view} or \tcode{edge_view} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:topo_sort} shows the functions and their return values.

While not shown in the examples, all functions have a final, optional allocator parameter that defaults to \tcode{std::allocator<bool>}. It is used for containers that are internal to the view. The \tcode{<bool>} argument has no particular meaning.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_topological_sort(g,seed))} & \tcode{vertex_view<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_topological_sort(g,seed,vvf))} & \tcode{vertex_view<VId,V,VV>} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : edges_topological_sort(g,seed))} & \tcode{edge_view<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_topological_sort(g,seed,evf))} & \tcode{edge_view<VId,false,E,EV>} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_topological_sort(g,seed))} & \tcode{edge_view<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_topological_sort(g,seed,evf))} & \tcode{edge_view<VId,true,E,EV>} \\
\hline
\end{tabular}}
\caption{topological\_sort View Functions}
\label{tab:topo_sort}
\end{center}
\end{table}

\subsection{Graph Container Interface}
The Graph Container Interface defines the primitive concepts, traits, types and functions used to define and access an adacency graph, no matter its internal design and organization. Thus, it is designed to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix, whether they are in the standard or external to the standard.

All algorithms in this proposal require that vertices are stored in random access containers and that \tcode{vertex_id_t<G>} is integral, and it is assumed that all future algorithm proposals will also have the same requirements. 

The Graph Container Interface is designed to support a wider scope of graph containers than required by the views and algorithms in this proposal. This enables for future growth of the graph data model (e.g. incoming edges on a vertex), or as a framework for graph implementations outside of the standard. For instance, existing implementations may have requirements that cause them to define features with looser constraints, such as sparse vertex\_ids, non-integral vertex\_ids, or storing vertices in associative bi-directional containers (e.g. std::map or std::unordered\_map). Such features require specialized implementations for views and algorithms. The performance for such algorithms will be sub-optimal, but is preferrable to run them on the existing container rather than loading the graph into a high-performance graph container and then running the algorithm on it, where the loading time can far outweigh the time to run the sub-optimal algorithm. To achieve this, care has been taken to make sure that the use of concepts chosen is appropriate for algorithm, view and container.

\subsubsection{Concepts}
Table \ref{tab:graph_concepts} summarizes the concepts in the Graph Container Interface, allowing views and algorithms to verify a graph implementation has the expected requirements for an \tcode{adjacency_list} or \tcode{sourced_adjacency_list}.

Sourced edges have a source\_id on them in addition to a target\_id. A \tcode{sourced_adjacency_list} has sourced edges.

% is_sourced_edge and is_sourced_edge_v structs are not included the table for brevity. We may want to add them in the future for completeness.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l L{12.0cm}}
\hline
    \textbf{Concept} & \textbf{Definition} \\
\hline
    \tcode{vertex_range<G>} & \tcode{vertices(g)} returns a sized, forward\_range; \tcode{vertex_id(g,ui)} exists\\
    \tcode{targeted_edge<G>} & \tcode{target_id(g,uv)} and \tcode{target(g,uv)} exist\\
    \tcode{sourced_edge<G>} & \tcode{source_id(g,uv)} and \tcode{source(g,uv)} exist\\
    \tcode{adjacency_list<G>} & \tcode{vertex_range<G>} and \tcode{targeted_edge<G,edge<G>>} and \tcode{edges(g,_)} functions return a forward\_range\\
    \tcode{sourced_adjacency_list<G>} & \tcode{adjacency_list<G>} and \tcode{sourced_edge<G, edge_t<G>>} and     \tcode{edge_id(g,uv)} exists \\
\hline
    \tcode{copyable_vertex<T,VId,VV>} & \tcode{convertible_to<T, copyable_vertex_t<VId, VV>>} \\
    \tcode{copyable_edge<T,Vid,EV>} & \tcode{convertible_to<T, copyable_edge_t<VId, EV>>} \\
\hline
\end{tabular}}
\caption{Graph Container Interface Concepts}
\label{tab:graph_concepts}
\end{center}
\end{table}

\subsubsection{Traits}
Table \ref{tab:graph_traits} summarizes the type traits in the Graph Container Interface, allowing views and algorithms to query the graph's characteristics.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{7.0cm}}
\hline
    \textbf{Trait} & \textbf{Type} & \textbf{Comment} \\
\hline
    \tcode{has_degree<G>} & concept & Is the \tcode{degree(g,u)} function available? \\
    \tcode{has_find_vertex<G>} & concept & Are the \tcode{find_vertex(g,_)} functions available? \\
    \tcode{has_find_vertex_edge<G>} & concept & Are the \tcode{find_vertex_edge(g,_)} functions available?\\
    \tcode{has_contains_edge<G>} & concept & Is the \tcode{contains_edge(g,uid,vid)} function available?\\
\hline
    \tcode{define_unordered_edge<G,E> : false_type} & struct & Specialize for edge implementation to derive from \tcode{true_type} for unordered edges \\
    \tcode{is_unordered_edge<G,E>} & struct & \tcode{conjunction<define_unordered_edge<E>, is_sourced_edge<G, E>>} \\
    \tcode{is_unordered_edge_v<G,E>} & type alias & \\
    \tcode{unordered_edge<G,E>} & concept & \\
\hline
    \tcode{is_ordered_edge<G,E>} & struct & \tcode{negation<is_unordered_edge<G,E>>} \\
    \tcode{is_ordered_edge_v<G,E>} & type alias & \\
    \tcode{ordered_edge<G,E>} & concept & \\
\hline
    \tcode{define_adjacency_matrix<G> : false_type} & struct & Specialize for graph implementation to derive from \tcode{true_type} for edges stored as a square 2-dimensional array \\
    \tcode{is_adjacency_matrix<G>} & struct & \\
    \tcode{is_adjacency_matrix_v<G>} & type alias & \\
    \tcode{adjacency_matrix<G>} & concept & \\
\hline
\end{tabular}}
\caption{Graph Container Interface Type Traits}
\label{tab:graph_traits}
\end{center}
\end{table}


\subsubsection{Types}
Table \ref{tab:graph_type} summarizes the type aliases in the Graph Container Interface. These are the types used to define the objects in a graph container, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.

The type aliases are defined by either a function specialization for the underlying graph container, or a refinement of one of those types (e.g. an iterator of a range). Table \ref{tab:graph_func} describes the functions in more detail.

\tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l L{1.5cm}}
\hline
    \textbf{Type Alias} & \textbf{Definition} & \textbf{Comment} \\
\hline
    \tcode{graph_reference_t<G>} & \tcode{add_lvalue_reference<G>} & \\
    \tcode{graph_value_t<G>} & \tcode{decltype(graph_value(g))} & optional \\
\hline
    \tcode{vertex_range_t<G>} & \tcode{decltype(vertices(g))} & \\    
    \tcode{vertex_iterator_t<G>} & \tcode{iterator_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_t<G>} & \tcode{range_value_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_reference_t<G>} & \tcode{range_reference_t<vertex_range_t<G>>} & \\    
    \tcode{vertex_id_t<G>} & \tcode{decltype(vertex_id(g))} & \\    
    \tcode{vertex_value_t<G>} & \tcode{decltype(vertex_value(g))} & optional \\
\hline
    \tcode{vertex_edge_range_t<G>} & \tcode{decltype(edges(g,u))} & \\    
    \tcode{vertex_edge_iterator_t<G>} & \tcode{iterator_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_t<G>} & \tcode{range_value_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_reference_t<G>} & \tcode{range_reference_t<vertex_edge_range_t<G>>} & \\    
    \tcode{edge_value_t<G>} & \tcode{decltype(edge_value(g))} & optional \\
\hdashline
    \multicolumn{3}{c}{The following is only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{edge_id_t<G>} & \tcode{decltype(pair(source_id(g,uv),target_id(g,uv)))} & \\    
\hline
\end{tabular}}
\caption{Graph Container Interface Type Aliases}
\label{tab:graph_type}
\end{center}
\end{table}


\subsubsection{Functions}

\phil{The functions in the Graph Container Interface are semi-stable. New functions are not expected, but overloads may be added or removed for different combinations of 
vertex\_id and references as we refine our use cases.}

Table \ref{tab:graph_func} summarizes the functions in the Graph Container Interface. These are the primitive functions used to access an adacency graph, no matter its internal design and organization. Thus, it is designed to be able to reflect all forms of adjacency graphs including a vector of lists, CSR graph and adjacency matrix.


\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l p{1.5cm} L{7.0cm}}
\hline
    \textbf{Function} & \textbf{Return Type} & \textbf{Complexity} & \textbf{Default Implementation} \\
\hline
    \tcode{graph_value(g)} & \tcode{graph_value_t<G>} & constant & n/a, optional \\
\hline
    \tcode{vertices(g)} & \tcode{vetex_range_t<G>} & constant & n/a \\
    \tcode{vertex_id(g,ui)} & \tcode{vetex_id_t<G>} & constant & \tcode{ui - begin(vertices(g))} \\
    & & & Override to define a different \tcode{vertex_id_t<G>} type (e.g. int32\_t). \\
    \tcode{vertex_value(g,u)} & \tcode{vertex_value_t<G>} & constant & n/a, optional \\
    \tcode{degree(g,u)} & \tcode{integral} & constant & \tcode{size(edges(g,u))} if \tcode{sized_range<vertex_edge_range_t<G>>} \\
    \tcode{find_vertex(g,uid)} & \tcode{vertex_iterator_t<G>} & constant & \tcode{begin(vertices(g)) + uid} \\
    & & & if \tcode{random_access_range<vertex_range_t<G>>}  \\
\hline
    \tcode{edges(g,u)} & \tcode{vertex_edge_range_t<G>} & constant & n/a \\
    \tcode{edges(g,uid)} & \tcode{vertex_edge_range_t<G>} & constant & \tcode{edges(g,*find_vertex(g,uid))} \\
    \tcode{target_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a \\
    \tcode{target(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + target_id(g, uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_value(g,uv)} & \tcode{edge_value_t<G>} & constant & n/a, optional \\
    \tcode{find_vertex_edge(g,u,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find(edges(g,u), [](uv) {target_id(g,uv)==vid;\})}} \\
    \tcode{find_vertex_edge(g,uid,vid)} & \tcode{vertex_edge_t<G>} & linear & \tcode{find_vertex_edge(g,*find_vertex(g,uid),vid)} \\
    \tcode{contains_edge(g,uid,vid)} & \tcode{bool} & constant & \tcode{uid < size(vertices(g)) \&\& vid < size(vertices(g))} if \tcode{is_adjacency_matrix_v<G>}.\\
    & & linear & \tcode{find_vertex_edge(g,uid) != end(edges(g,uid))} otherwise. \\
\hdashline
    \multicolumn{4}{c}{The following are only available when the optional \tcode{source_id(g,uv)} is defined for the edge} \\
\hdashline
    \tcode{source_id(g,uv)} & \tcode{vertex_id_t<G>} & constant & n/a, optional \\
    \tcode{source(g,uv)} & \tcode{vertex_t<G>} & constant & \tcode{*(begin(vertices(g)) + source_id(g,uv))} if \tcode{random_access_range<vertex_range_t<G>> \&\& integral<target_id(g,uv)>} \\
    \tcode{edge_id(g,uv)} & \tcode{edge_id_t<G>} & constant & \tcode{pair(source_id(g,uv),target_id(g,uv))} \\
\hline
\end{tabular}}
\caption{Graph Container Interface Functions}
\label{tab:graph_func}
\end{center}
\end{table}

Functions that have n/a for their Default Implementation must be defined by the author of a Graph Container implementation. \tcode{graph_value(g)}, \tcode{vertex_value(g,u)} and \tcode{edge_value(g,uv)} can be optionally implemented, depending on whether the graph container supports values on the graph, vertex and edge types.

\tcode{vertex_id_t<G>} is defined by the type returned by \tcode{vertex_id(g)} and it defaults to the difference\_type of the underlying container used for vertices (e.g int64\_t for 64-bit systems). This is sufficient for all situations. However, there are often space and performance advantages if a smaller type is used, such as int32\_t or even int16\_t. It is recommended to consider overriding this function for optimal results, assuring that it is also large enough for the number of possible vertices and edges in the application. It will also need to be overridden if the implementation doesn't expose the vertices as a range.

\tcode{find_vertex(g,uid)} is constant complexity because all algorithms in this proposal require that \tcode{vertex_range_t<G>} is a random access range. 

If the concept requirements for the default implementation aren't met by the graph container the function will need to be overridden.

Edgelists are assumed to be either be an edgelist view of an adjacency graph, or a standard range with source\_id and target\_id values. There is no need for additional functions when a range is used.

\subsection{Graph Container Implementation}

\subsubsection{csr\_graph Graph Container}
The csr\_graph is a high-performance graph container that uses \href{https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_\%28CSR\%2C_CRS_or_Yale_format\%29}{Compressed Sparse Row} format to store it's vertices, edges and associated values. Once constructed, vertices and edges cannot be added or deleted but values on vertices and edges can be modified.
\\

The following listing shows the prototype for the \tcode{csr_graph}. A fuller description, including its constructors, can be found in the \tcode{<csr_graph} header section.

Only the constructors, destructor and assignment operators for \tcode{csr_graph} are public. No other member functions or types are exposed. All other types are only accessible through the types and functions in the Graph Container Interface.

When a value type template argument (EV, VV, GV) is void then no extra overhead is incurred for it. The selection of the VId template argument impacts the inter storage requirements. If you have a small graph where the number of vertices is less than 256, and the number of edges is less than 256, then a \tcode{uint8_t} would be sufficient.

\begin{lstlisting}
template <class    EV     = void,     // Edge Value type
          class    VV     = void,     // Vertex Value type
          class    GV     = void,     // Graph Value type
          integral VId    = uint32_t, // vertex id type
          integral EIndex = uint32_t, // edge index type
          class    Alloc  = allocator<uint32_t>> // for internal containers
class csr_graph;
\end{lstlisting}

\subsubsection{csr\_partite\_graph Graph Container (In Design)}
\phil{This is experimental}

The \tcode{csr_partite_graph} extends \tcode{csr_graph} to have multiple partitions, where each partition defines a different value type for the vertex and edge. The same template arguments are used, but it also expects that the VV and EV arguments are \tcode{std::variant}, and the number of types in each is the same. The number of types in the variants define the number of partitions. The edge types apply to the outgoing edges of the vertices in the same partition. \tcode{std::monostate} can be used if no value is needed for a vertex or edge in a partition.

Example usage
\begin{lstlisting}
using VV = std::variant<int,double,bool>;
using EV = std::variant<int,int,std::monostate>; // no outgoing edges in the final partition
using G  = csr_partite_graph<EV, VV>;
G g = ...; // construct g with data
for(size_t p = 0; p < partition_size(g); ++p) {
  for(auto&& [uid,u] : partition(g,p)) {
    for(auto&& [vid,uv] : incidence(g,u)) {
       // do interesting things with uv
    }
  }
}
\end{lstlisting}