%% \chapter{Algorithms}

\clearpage

\section{Algorithm Selection} \label{other_algo}

\phil{Use \tcode{basic_index_adjacency_list} as the concept for all algorithms.}

When determining the algorithms to propose we split them into different tiers. Tier 1 algorithms are included
in this proposal. The algorithms selected are a result of balancing a few things:
\begin{itemdescr}
\begin{itemize}
      \item Include a rich enough set of algorithms for the library to be useful.
      \item Include algorithms with well-defined functionality and agreed-upon algorithmic description.
      \item Don't include so many that the proposal will get bogged down for years and years.
\end{itemize}
\end{itemdescr}

\subsection{Tier 1 Algorithms}
\begin{multicols}{3}
      \emph{Traversal}
      \begin{itemize}
            \item Breadth-First search
            \item Depth-First search
            \item Topological sort
      \end{itemize}
      \emph{Shortest Paths}
      \begin{itemize}
            %\item Shortest paths (driver interface)
            \item Dijkstra's algorithm
            \item Bellman-Ford algorithm
      \end{itemize}
      \emph{Clustering}
      \begin{itemize}
            \item Triangle counting
      \end{itemize}
\columnbreak
      \emph{Communities}
      \begin{itemize}
            \item Label propagation
      \end{itemize}
      \emph{Components}
      \begin{itemize}
            \item Articulation points
            \item Connected components
            \item Biconnected components
            \item Kosaraju's Strongly CC
            \item Tarjan's Strongly CC
      \end{itemize}
\columnbreak
      \emph{Maximal Independent Set}
      \begin{itemize}
            \item Maximal independent set
      \end{itemize}
      \emph{Link Analysis}
      \begin{itemize}
            \item Jaccard coefficient
      \end{itemize}
      \emph{Minimal Spanning Tree}
      \begin{itemize}
            \item Kruskal's MST
            \item Prim's MST
      \end{itemize}

\vfill\null
\end{multicols}

Breadth-First Search, Shortest Paths and Topological Sort include single-source and multi-source versions with multiple targets.

\subsection{Other Algorithms}
Additional algorithms that were considered but not included in this proposal are shown in Table \ref{tab:other_algorithms}. 
Tier X algorithms are variations of shortest paths algorithms that complement the Single Source, Multiple Target algorithms 
in this proposal.
It is assumed that future proposals will include them, thought the exact mix for each proposal will depend on feedback received
and our experience with the current proposal.

\phil{We may want to revisit the Driver idea in the future after we have more algorithms.}
%The Shortest Paths Driver is an idea of having a unified interface that chooses the best Shortest Path algorithm
%based on characteristics like non-negative edge weight, multi-threading, etc.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l|l|l}
\hline
    \textbf{Tier 2} & \textbf{Tier 3} & \textbf{Tier X} \\
\hline
    All Pairs Shortest Paths & Jones Plassman & Single Source, Single Target: Shortest Paths Driver\\
    Floyd-Warshall & Cores: k-cores & Single Source, Single Target: BFS \\
    Johnson & Cores: k-truss & Single Source, Single Target: Dijkstra \\
    Centrality: Betweenness Centrality & Subgraph Isomorphism & Single Source, Single Target: Bellman-Ford \\
    Coloring: Greedy & & Single Source, Single Target: Delta Stepping \\
    Communities: Louvain & &  \\
    Connectivity: Minimum Cuts & & Multiple Source: Shortest Paths Driver \\
    Transitive Closure & & Multiple Source: BFS \\
    Flows: Edmunds Karp & & Multiple Source: Dijkstra \\
    Flows: Push Relabel & & Multiple Source: Bellman-Ford \\
    Flows: Boykov Kolmogorov & & Multiple Source: Delta Stepping \\
    Link Analysis: Adamic-Adar Index & &  \\
    Pathfinding: A* & & Multiple Source, Single Target: Shortest Paths Driver\\
    Best-first search & & Multiple Source, Single Target: BFS \\
    & & Multiple Source, Single Target: Dijkstra \\
    & & Multiple Source, Single Target: Bellman-Ford \\
    & & Multiple Source, Single Target: Delta Stepping \\
\hline
\end{tabular}}
\caption{Other Algorithms}
\label{tab:other_algorithms}
\end{center}
\end{table}

\andrew{All Pairs: Tier 2?  People bring this up alot -- but it is very expensive in terms of computation and memory.}
\phil{If it's useful to enough people it should be included. Users can make their own determination of whether they want to use it, based on the cost.}

\phil{The same variations for Shortest Paths algorithms can also be useful for topological sort.}

% Floyd-Warshall $\mathcal{O}(N^2)$}
% Johnson $\mathcal{O}(N^2)$}

\clearpage
\section{Algorithm Concepts}

%\andrew{Need to develop this ala CppCon 2021 talk.}

The abstraction that is used for describing and analyzing almost all graph algorithms is the adjacency list.  Naturally then implementations of graph algorithms in C++ will operate on a data structure representing an adjacency list.  And generic algorithms will be written in terms of concepts that capture the essential operations that a concrete data structure must provide in order to be used as an abstraction of an adjacency list.

Most fundamentally (as illustrated above), an adjacency list is a collection of vertices, each of which has a collection of outgoing edges.  In terms of existing C++ concepts, we can consider an adjacency list to be a range of ranges (or, more specifically, a random access range of forward ranges).  The outer range is the collection of vertices, and the inner ranges are the collections of outgoing edges.

%\andrew{Is it better to list the concepts here or forward reference them?  Kind of a circularity.  But maybe the sequence of concepts - algorithms - concrete data types is the right one.  OTOH, std::ranges use ordering overview library-concepts-containers-algorithms.  Since a graph is a range of ranges, maybe we should follow that.}

%\phil{I think this is a good place, just before they're used in the text for this section.}
% Additional concepts used by algorithms.

\begin{lstlisting}
// For exposition only
template <class G, class WF, class DistanceValue, class Compare, class Combine>
concept basic_edge_weight_function = // e.g. weight(uv)
      is_arithmetic_v<DistanceValue> && 
      strict_weak_order<Compare, DistanceValue, DistanceValue> &&
      assignable_from<add_lvalue_reference_t<DistanceValue>,
            invoke_result_t<Combine, DistanceValue, invoke_result_t<WF, edge_reference_t<G>>>>;

// For exposition only
template <class G, class WF, class DistanceValue>
concept edge_weight_function = // e.g. weight(uv)
      is_arithmetic_v<invoke_result_t<WF, edge_reference_t<G>>> &&
      basic_edge_weight_function<G,
                                  WF,
                                  DistanceValue,
                                  less<DistanceValue>,
                                  plus<DistanceValue>>;
\end{lstlisting}

\begin{comment}
      \phil{Queueable isn't being used.}
      \begin{lstlisting}
      // queueableQ can represent std::queue and std::priority\_queue
      template <class Q>
      concept queueable = requires(Q&& q, Q::value_type value) {
      Q::value_type;
      Q::size_type;
      Q::reference;

      {q.top()};
      {q.push(value)};
      {q.pop()};
      {q.empty()};
      {q.size()};
      };
      \end{lstlisting}
\end{comment}



\section{Traversal}

\subsection{Breadth-First Search}

\subsubsection{Initialization}

{\small
      \lstinputlisting{D3128_Algorithms/src/breadth_first_search_helpers.hpp}
}

\begin{itemdescr}
      \effects
      \begin{itemize}
            \item
                  Each \lstinline{predecessors[i]} is initialized to \lstinline{i}.
      \end{itemize}
\end{itemdescr}


\subsubsection{Breadth-First Search, Single Source}
Compute the breadth-first path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}.

\phil{This needs to be a subset of Dijkstra, without the weight, compare and combine functions. It needs a visitor.}

\phil{Is distance always needed? Should we remove it, since it is easily evaluated using Dijkstra?} \phil{Check BGL implementation.}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}((|E| + |V|)\log{|V|})$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting{D3128_Algorithms/src/breadth_first_search.hpp}
}

\begin{itemdescr}
      %\pnum\mandates
      % \pnum
\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_breadth_first_search}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_breadth_first_search}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the lowest number of edges from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{breadth_first_search_infinite_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      \pnum\throws
            \begin{itemize}
                  \item \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(g)}.
            \end{itemize}
      \pnum\complexity
            \begin{itemize}
                  \item $\mathcal{O}((|E| + |V|)\log{|V|})$
                  \item Note that complexity may be $\mathcal{O}(|E| + |V|\log{|V|)}$ for certain implementations. 
            \end{itemize}
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Depth-First Search}
\textit{Coming soon.}

\subsection{Topological Sort}
\subsection{Topological Sort, Single Source}
A linear ordering of vertices such that for every directed edge (u,v) from vertex u to vertex v, u comes before v in the ordering.

\subsubsection{Initialization}

{\small
      \lstinputlisting{D3128_Algorithms/src/topological_sort_helpers.hpp}
}

\begin{itemdescr}
      \effects
      \begin{itemize}
            \item
                  Each \lstinline{predecessors[i]} is initialized to \lstinline{i}.
      \end{itemize}
\end{itemdescr}

\subsubsection{Topological Sort, Single Source}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting{D3128_Algorithms/src/topological_sort.hpp}
}

\phil{Update to mimic Dijsktra overloads, and include a visitor}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_topological_sort}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      %\pnum\throws \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(graph)}.  \\
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}



\section{Shortest Paths}

\begin{comment}
      \subsection{Driver Interface}

      \andrew{I am not sure we should have the unified interface.  We need to be more parsimonious in our interfaces.  Users can read the documentation for which algorithms to use.  And, if they are using graph algorithms, we should assume a certain level of knowledge about graph algorithms.  OTOH, it is only a handful of algorithms.}

      \andrew{I am also not sure we should have ``shortest distance'' variants.  That doubles the number of functions in the interface.
            For each function we have shortest paths, s-t paths, multi-source paths, parallel = 6X variants for each base function.  If we add shortest distances, that will make 12X.  OTOH, we could consider not having s-t paths or not having multi-source paths -- which would leave 4X for each base function.  However, I think people will want s-t and multi-source.
      }
      \phil{\tcode{dijkstra_shortest_distances} includes predecessor and distances, so excluding \tcode{dijkstra_shortest_distances} won't impact 
      the user much.}


      {\small
            \lstinputlisting{D3128_Algorithms/src/shortest_paths.hpp}
      }

      \andrew{The variety of algorithms was inspired by networkx....  Which also had ``distance'' variants.}

      \phil{I assume \tcode{adjacency_list_graph} is the same as our \tcode{adjacency_list}. \tcode{bidirectional_adjacency_list_graph} is new; what to do with it?}
\end{comment}


\subsection{Initialization}

{\small
      \lstinputlisting{D3128_Algorithms/src/shortest_paths_helpers.hpp}
}
\begin{itemdescr}
      \pnum
      \effects:
            \begin{itemize}
                  \item
                        \lstinline{init_shortest_paths(distances)} sets all elements in \lstinline{distance} to \lstinline{shortest_path_infinite_distance()}
                  \item
                        \lstinline{init_shortest_paths(distances,predecessors)} does the same as \lstinline{shortest_path_infinite_distance(distances)}
                        and sets \lstinline{predecessors[i] = i} for \lstinline{i < size(predecessors)}.
            \end{itemize}
      \pnum\returns 
            \begin{itemize}
                  \item \lstinline{shortest_path_infinite_distance()} returns the largest distance value,
                        typically \lstinline{numeric_limits<DistanceValue>::max()} for numeric types.
                  \item \lstinline{shortest_path_zero()} returns a value for for a zero-length path,
                        typically \lstinline{0} for numeric types.
            \end{itemize}
\end{itemdescr}


\subsection{Dijkstra Shortest Paths and Shortest Distances}

Compute the shortest path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}
using non-negative weights.

It is valid to make multiple calls to \tcode{dijkstra_shortes_paths} or \tcode{dijkstra_shortest_distances} 
with different sources without reinitializing the predecessor and distances ranges between calls. Shorter 
paths to previously found vertices will be identified.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}((|E| + |V|)\log{|V|})$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} Yes \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

Note that complexity may be $\mathcal{O}(|E| + |V|\log{|V|)}$ for certain implementations that use a Fibonacci heap
instead of a binary heap implemented with \tcode{std::priority_queue}.

\subsubsection{Dijkstra Shortest Paths}

\paragraph{Single-Source Shortest Paths}
{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_shortest_paths.hpp}
}

\paragraph{Multi-Source Shortest Paths}
{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_shortest_paths_multi.hpp}
}

\andrew{Should we include the check for negative weights (performance)?}
\phil{It's the cost of safety. BGL did it, so there is precedent. The check isn't done if weights are unsigned 
integral values.}

\begin{itemdescr}
      \pnum\mandates
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)} for the single-source version.
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}, for each \lstinline{source} in \lstinline{sources}, 
                                   for the multi-source version.
                  \item
                        The weight function \lstinline{w} must return a non-negative value.
            \end{itemize}
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_shortest_paths}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_infinite_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      \pnum\throws 
            \begin{itemize}
                  \item An \tcode{out_of_range} exception is thrown in the following cases:
                        \begin{itemize}
                              \item \lstinline{size(distances) < size(vertices(g))}
                              \item \lstinline{size(predecessor) < size(vertices(g))}
                              \item \lstinline{source} is not in the range \lstinline{0 <= source < num_vertices(graph)}.
                              \item The weight function returns a negative value. This check is not made if the weight
                                    value type is an unsigned integral type.
                        \end{itemize}
            \end{itemize}
      \pnum\complexity
            \begin{itemize}
                  \item $\mathcal{O}((|E| + |V|)\log{|V|})$ based on using the binary heap in \tcode{std::priority_queue}.
                  \item An implementation may choose to use a Fibonacci heap for a complexity of $\mathcal{O}(|E| + |V|\log{|V|})$.
            \end{itemize}
      \pnum\remarks 
            \begin{itemize}
                  \item Duplicate sources do not affect the algorithm's complexity or correctness.
                  \item Bellman-Ford Shortest Paths allows negative weights with the consequence of greater complexity.
            \end{itemize}
      %\pnum\errors
\end{itemdescr}

\subsubsection{Dijkstra Shortest Distances}
This is the same as \textit{Shortest Paths} except that it excludes the predecessors,
giving a small performance improvement with lower memory overhead.

\paragraph{Single-Source Shortest Distances}
{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_shortest_dists.hpp}
}

\paragraph{Multi-Source Shortest Distances}
{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_shortest_dists_multi.hpp}
}

\begin{itemdescr}
      \pnum\mandates
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)} for the single-source version. 
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}, for each \lstinline{source} in \lstinline{sources}, 
                                   for the multi-source version.
                  \item
                        The weight function \lstinline{w} must return a non-negative value.
            \end{itemize}
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_infinite_distance()}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      \pnum\throws 
            \begin{itemize}
                  \item An \tcode{out_of_range} exception is thrown in the following cases:
                        \begin{itemize}
                              \item \lstinline{size(distances) < size(vertices(g))}
                              \item \lstinline{source} is not in the range \lstinline{0 <= source < num_vertices(graph)}.
                              \item The weight function returns a negative value. This check is not made if the weight
                                    value type is an unsigned integral type.
                        \end{itemize}
            \end{itemize}
      \pnum\complexity
            \begin{itemize}
                  \item $\mathcal{O}((|E| + |V|)\log{|V|})$ based on using the binary heap in \tcode{std::priority_queue}.
                  \item An implementation may choose to use a Fibonacci heap for a complexity of $\mathcal{O}(|E| + |V|\log{|V|})$.
            \end{itemize}
      \pnum\remarks 
            \begin{itemize}
                  \item Duplicate sources do not affect the algorithm's complexity or correctness.
                  \item Bellman-Ford Shortest Distances allows negative weights with the consequence of greater complexity.
            \end{itemize}
      %\pnum\errors
\end{itemdescr}

\subsubsection{Dijkstra Visitor}
\tcode{dijkstra_visitor_base} defines callacks for events in the \tcode{dijkstra_shortest_paths}
and \tcode{dijkstra_shortest_distances} algorithms. To use it, a new class is derived from 
\tcode{dijkstra_visitor_base} and the desired event function(s) are overridden. The instance of the
new visitor is passed to the Dijkstra algorithm. No \tcode{overload} keyword should be used.

Empty event functions have no overhead because they are removed by the optimizer. 

The events included are the same as the Dijkstra Shortest Path algorithms in the boost::graph 
library.

The \tcode{vdesc} parameter is a vertex descriptor, which is a struct with vertex \tcode{id} and \tcode{vertex}
reference members. The \tcode{edesc} parameter is an edge descriptor, which is a struct with \tcode{source_id},
\tcode{target_id}, and \tcode{edge} reference members.

{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_visitor_base.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{on_initialize_vertex(vdesc)} is called once for each vertex before
                        the algorithm is run.
                  \item
                        \lstinline{on_discover_vertex(vdesc)} is called once for each source vertex passed
                        to the algorithm.
                  \item
                        \lstinline{on_examine_vertex(vdesc)} is called for a vertex before any of 
                        its outgoing edges are examined. It is possible that it will be called multiple times 
                        for the same vertex if paths are found to it from other vertices with a shorter distance.
                  \item
                        \lstinline{on_finish_vertex(vdesc)} is called for vertex that is being examined,
                        after all its outgoing edges have been examined.
                  \item
                        \lstinline{on_examine_edge(edesc)} is called for edge of the source vertex that is
                        being examined.
                  \item
                        \lstinline{on_edge_relaxed(edesc)} is called when the distance to the target vertex of the edge
                        is relaxed, or decreased.
                  \item
                        \lstinline{on_edge_not_relaxed(edesc)} is called when the distance to the target vertex of the edge
                        is not relaxed, or not decreased.
            \end{itemize}
      %\pnum\result
      %\pnum\returns 
      \pnum\throws 
            \begin{itemize}
                  \item If an event function throws an exception, the algorithm will terminate, the exception will 
                  be propagated to the caller, and the state of the distances and predecessors ranges is undefined.
            \end{itemize}
      %\pnum\complexity
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsubsection{Dijkstra Visitor Concept}
The \tcode{dijkstra_visitor} concept is used to validate the visitor passed to the algorithms.

{\small
      \lstinputlisting{D3128_Algorithms/src/dijkstra_visitor_concept.hpp}
}


\subsection{Bellman-Ford Shortest Paths and Shortest Distances}
Compute the shortest path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}.

It is valid to make multiple calls to \tcode{bellman_ford_shortest_paths} or \tcode{bellman_ford_shortest_distances} 
with different sources without reinitializing the predecessor and distances ranges between calls. Shorter 
paths to previously found vertices will be identified. However, it is recommended that the multi-source version
be when possible to avoid the performance penalty of repeated calls to the algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E| \cdot |V|)$ \\
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} Yes \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

%\andrew{Complexity is really is atrocious.  Suitable only for really small graphs.}

The Bellman-Ford algorithm supports the use of negative edge weights, at cost in performance. 
Because of its complexity, it can only be used for small graphs.
If a user can guarantee that a graph has positive edge weights then Dijkstra's algorithm 
provides far better performance.

There is a special case where edges form a negative cycle. 
"If a graph contains a 'negative cycle' (i.e. a cycle whose edges sum to a negative value) 
that is reachable from the source, then there is no cheapest path: any path that has a point 
on the negative cycle can be made cheaper by one more walk around the negative cycle. In such 
a case, the Bellman–Ford algorithm can detect and report the negative cycle." 
\textbf{Wikipedia} (\cite{REF_bellman})

\tcode{find_negative_cycle} can be called after calling \tcode{bellman_ford_shortest_paths} to
get the vertex ids of the negative weight cycle.

\subsubsection{Bellman-Ford Shortest Paths}

\paragraph{Single-Source Shortest Paths}
{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_shortest_paths.hpp}
}

\paragraph{Multi-Source Shortest Paths}
{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_shortest_paths_multi.hpp}
}

\begin{itemdescr}
      \pnum\mandates
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)} for the single-source version. 
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}, for each \lstinline{source} in \lstinline{sources}, 
                                   for the multi-source version.
            \end{itemize}
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_shortest_paths}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_infinite_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      \pnum\returns 
            \begin{itemize}
                  \item \lstinline{optional<vertex_id_t<G>} If no negative weight cycle is found, 
                        there is no associated vertex id. If a negative weight cycle is found, a
                        vertex id in the cycle is returned. \lstinline{find_negative_cycle}
                        can be called to get the vertex ids of the cycle.
            \end{itemize}
      \pnum\throws 
            \begin{itemize}
                  \item An \tcode{out_of_range} exception is thrown in the following cases:
                        \begin{itemize}
                              \item \lstinline{size(distances) < size(vertices(g))}
                              \item \lstinline{source} is not in the range \lstinline{0 <= source < num_vertices(graph)}.
                        \end{itemize}
            \end{itemize}
      \pnum\complexity $\mathcal{O}(|E| \cdot |V|)$. Complexity may also be affected by the callers visitor functionality. \\
      \pnum\remarks 
            \begin{itemize}
                  \item Duplicate sources do not affect the algorithm's complexity or correctness.
                  \item Unlike Dijkstra's algorithm, Bellman-Ford allows negative edge weights. 
                        Performance constraints limit this to smaller graphs.
            \end{itemize}
      %\pnum\errors
\end{itemdescr}

\subsubsection{Bellman-Ford Shortest Distances}

This is the same as \textit{Shortest Paths} except that it excludes the predecessors,
giving a small performance improvement with lower memory overhead.

\paragraph{Single-Source Shortest Distances}
{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_shortest_dists.hpp}
}

\paragraph{Multi-Source Shortest Distances}
{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_shortest_dists_multi.hpp}
}

\begin{itemdescr}
      \pnum\mandates
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)} for the single-source version. 
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}, for each \lstinline{source} in \lstinline{sources}, 
                                   for the multi-source version.
            \end{itemize}
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_infinite_distance()}.
            \end{itemize}
      %\pnum\result
      \pnum\returns 
      \begin{itemize}
            \item \lstinline{optional<vertex_id_t<G>} If no negative weight cycle is found, 
                  there is no associated vertex id. If a negative weight cycle is found, a
                  vertex id in the cycle is returned. \lstinline{bellman_ford_shortest_paths} must be used
                  to get the predecessors if it is importantant to get the vertex ids of the cycle
                  using \lstinline{find_negative_cycle}.
      \end{itemize}
\pnum\throws 
            \begin{itemize}
                  \item An \tcode{out_of_range} exception is thrown in the following cases:
                        \begin{itemize}
                              \item \lstinline{size(distances) < size(vertices(g))}
                              \item \lstinline{source} is not in the range \lstinline{0 <= source < num_vertices(graph)}.
                        \end{itemize}
            \end{itemize}
      \pnum\complexity $\mathcal{O}(|E| \cdot |V|)$. Complexity may also be affected by the callers visitor functionality. \\
      \pnum\remarks 
            \begin{itemize}
                  \item Duplicate sources do not affect the algorithm's complexity or correctness.
                  \item Unlike Dijkstra's algorithm, Bellman-Ford allows negative edge weights. 
                        Performance constraints limit this to smaller graphs.
            \end{itemize}
      %\pnum\errors
\end{itemdescr}


\subsubsection{Bellman-Ford Visitor}

\tcode{bellman_visitor_base} defines callacks for events in the \tcode{bellman_ford_shortest_paths}
and \tcode{bellman_ford_shortest_distances} algorithms. To use it, a new class is derived from 
\tcode{bellman_visitor_base} and the desired event function(s) are overridden. The instance of the
new visitor is passed to the Bellman-Ford algorithm. No \tcode{overload} keyword should be used.

Empty event functions have no overhead because they are removed by the optimizer. 

The events included are the same as the Bellman-Ford Shortest Path algorithms in the boost::graph 
library.

{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_visitor.hpp}
}

\phil{Are the \textit{minimized} events needed? BGL included them but only returned a \tcode{bool}, 
so the only way to get a vertex id of the cycle was to implement the \tcode{on_edge_not_minimized} 
event. Now, a vertex id is returned when a negative weight cycle is found.}

\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{on_examine_edge(edesc)} is called for edge that is being examined. This will be called 
                        multiple times for the same edge.
                  \item
                        \lstinline{on_edge_relaxed(edesc)} is called when the distance to the target vertex of the edge
                        is relaxed, or decreased. This may be called multiple times for the same edge.
                  \item
                        \lstinline{on_edge_not_relaxed(edesc)} is called when the distance to the target vertex of the edge
                        is not relaxed, or not decreased.
                  \item
                        \lstinline{on_edge_minimized(edesc)} is called when an edge has not been detected in a negative 
                        weight cycle. This will be called at most once for each edge.
                  \item
                        \lstinline{on_edge_not_minimized(edesc)} is called when a cycle of negative weights is discovered.
                        After returning, the algorithm will terminate and return \lstinline{false}. This will only be called
                        once at most.
            \end{itemize}
      %\pnum\result
      %\pnum\returns 
      \pnum\throws 
            \begin{itemize}
                  \item If an event function throws an exception, the algorithm will terminate, the exception will 
                  be propagated to the caller, and the state of the distances and predecessors ranges is undefined.
            \end{itemize}
      %\pnum\complexity
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsubsection{Bellman-Ford Visitor Concept}

The \tcode{bellman_visitor} concept is used to validate the visitor passed to the algorithms.

{\small
      \lstinputlisting{D3128_Algorithms/src/bellman_visitor_concept.hpp}
}

\subsubsection{Finding the Negative Cycle}
If a cycle with negative weights is found, it's possible to get the vertex ids of the cycle
using \tcode{find_negative_cycle} after calling \tcode{bellman_ford_shortest_paths}. It is
not possible to get the cycle from \tcode{bellman_ford_shortest_distances} because it does
not evaluate predecessors.

{\small
      \lstinputlisting{D3128_Algorithms/src/find_negative_cycle.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item \lstinline{predecessors} must be evaluated by \lstinline{bellman_ford_shortest_paths}.
                  \item \lstinline{cycle_vertex_id} is the return value of \lstinline{bellman_ford_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        All vertex ids in the negative weight cycle are written to the \lstinline{out_cycle} output
                        iterator.
            \end{itemize}
      %\pnum\result
      %\pnum\returns 
      %\pnum\throws 
      \pnum\complexity  $\mathcal{O}(N)$, where \textit{N} is the number of vertex ids in the cycle. \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Clustering}
\subsection{Triangle Counting}
Compute the number of triangles in a graph.

\andrew{The literature for triangle counting is typically for undirected graphs. Directed graphs
      can also be evaluated by disabling the checks that limit it to the 2nd half of the graph.}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(N^3)$ \\
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} No & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=6]{D3128_Algorithms/src/tc.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      %\pnum\effects
      %\pnum\result
      \pnum\returns Number of triangles \\
      %\pnum\throws
      %\pnum\complexity \\
      \pnum\remarks
      To avoid duplicate counting, only directed triangles of a certain orientation will be detected. If \tcode{vertex_id(u) < vertex_id(v) < vertex_id(w)}, count triangle if graph contains edges \tcode{uv, vw, uw}.
      %\pnum\errors
\end{itemdescr}


\section{Communities}
\subsection{Label Propagation}
Propagate vertex labels by setting each vertex's label to the most popular label of its neighboring vertices. Every vertex voting on its new label represents one iteration of label propagation. Vertex voting order is randomized every iteration. The algorithm will iterate until label convergence, or optionally for a user specified number of iterations. Convergence occurs when no vertex label changes from the previous iteration. $\mathcal{O}(M)$ complexity is based on the complexity of one iteration, with number of iterations required for convergence considered small relative to graph size.

Some label propagation implementations use vertex ids as an initial labeling. This is not supported here because the label type can be more generic than the vertex id type. User is responsible for meaningful initial labeling.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(M)$ \\
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} Yes & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

\phil{What is M?}

{\small
      \lstinputlisting[firstline=4,lastline=11]{D3128_Algorithms/src/lp.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{label} contains initial vertex labels.
                  \item
                  \lstinline{rng} is a random number generator for vertex voting order.
                  \item
                  \lstinline{max_iters} is the maximum number of iterations of the label propagation, or equivalently the maximum distance a label will propagate from its starting vertex.
            \end{itemize}
      \pnum\effects \lstinline{label[uid]} is the label assignments of vertex id \lstinline{uid} discovered by label propagation.
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity
      \pnum\remarks
      User is responsible for initial vertex labels.
      %\pnum\errors
\end{itemdescr}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(M)$ \\
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} Yes & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=13,lastline=21]{D3128_Algorithms/src/lp.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{label} contains initial vertex labels.
                  \item
                  \lstinline{empty_label} defines a label that is considered empty and will not be propagated.
                  \item
                  \lstinline{rng} is a random number generator for vertex voting order.
                  \item
                  \lstinline{max_iters} is the maximum number of iterations of the label propagation, or equivalently the maximum distance a label will propagate from its starting vertex.
            \end{itemize}
      \pnum\effects \lstinline{label[uid]} is the label assignments of vertex id \lstinline{uid} discovered by label propagation.
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity
      \pnum\remarks
      User is responsible for initial vertex labels.
      %\pnum\errors
\end{itemdescr}

\section{Components}
\subsection{Articulation Points}
Find articulation points, or cut vertices, which when removed disconnect the graph into multiple components. Time complexity based on Hopcroft-Tarjan algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
     \lstinputlisting[firstline=4,lastline=6]{D3128_Algorithms/src/connected_components.hpp}
}

\phil{Should target of output iterator be convertible to vertex\_id, not same\_as vertex\_id?}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  Output iterator \lstinline{cut_vertices} can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                  Output iterator \lstinline{cut_vertices} contains articulation point vertices, those which removed increase the number of components of \lstinline{g}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{BiConnected Components}
Find the biconnected components, or maximal biconnected subgraphs of a graph, which are components that will remain connected if a vertex is removed. Time complexity based on Hopcroft-Tarjan algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
     \lstinputlisting[firstline=11,lastline=16]{D3128_Algorithms/src/connected_components.hpp}
}

\phil{\tcode{push_back}, \tcode{push_front} and \tcode{insert} are all valid ways to add to containers that support forward\_range,
      depending on the specific container type. Are all supported?}

\phil{I think \tcode{convertible_to<...,vertex_id<G>>} would be better than \tcode{integral<...>} because it will catch truncation when 
      assigning vertex\_id to smaller ints in the inner container.}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{components} is a container of containers. The inner container stores vertex ids.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                  \lstinline{components} contains groups of biconnected components.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Connected Components}
Find weakly connected components of a graph. Weakly connected components are subgraphs where a path exists between all pairs of vertices when ignoring edge direction.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} No & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
     \lstinputlisting[firstline=21,lastline=24]{D3128_Algorithms/src/connected_components.hpp}
}

\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the connected component id of vertex \lstinline{v}.
                  \item
                        There is at least one Connected Component, with compondent id of \lstinline{0}, for \lstinline{num_vertices(g) > 0}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Strongly Connected Components}
\subsubsection{Kosaraju's SCC}
Find strongly connected components of a graph using Kosaraju's algorithm. Strongly connected components are subgraphs where a path exists between all pairs of vertices.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=29, lastline=34]{D3128_Algorithms/src/connected_components.hpp}
}
\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{g_t} is the transpose of \lstinline{g}. Edge \lstinline{uv} in \lstinline{g} implies edge \lstinline{vu} in \lstinline{g_t}. \lstinline{num_vertices(g)} equals \lstinline{num_vertices(g_t)}.
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the strongly connected component id of vertex \lstinline{v}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsubsection{Tarjan's SCC}
Find strongly connected components of a graph using Tarjan's algorithm. Strongly connected components are subgraphs where a path exists between all pairs of vertices.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} Yes & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} Yes & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=39,lastline=43]{D3128_Algorithms/src/connected_components.hpp}
}

\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the strongly connected component id of \lstinline{v}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Maximal Independent Set}
\subsection{Maximal Independent Set}
Find a maximally independent set of vertices in a graph starting from a seed vertex. An independent vertex set indicates no pair of vertices in the set are adjacent.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|E|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} No & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting{D3128_Algorithms/src/mis.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= seed < num_vertices(graph)}.
                  \item
                        \lstinline{mis} output iterator can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
      \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        Output iterator \lstinline{mis} contains maximal independent set of vertices containing \lstinline{seed}, 
                        which is a subset of \lstinline{vertices(graph)}. \\
      \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Link Analysis}

% pagerank removed because there are many variations and corner cases to cover
% It fits better in an example. 08-Nov-2023

\subsection{Jaccard Coefficient}
Calculate the Jaccard coefficient of a graph

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}(|N|^3)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} No & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=6]{D3128_Algorithms/src/jaccard.hpp}
}

\phil{Consider using \tcode{out(uid,vid,uv,val)} as the function descriptor in Preconditions to make it more readable.}

\phil{Would an output iterator be appropriate? \tcode{pair<pair<vertex_id_t<G>,vertex_id_t<G>>,T>} might work for the output type. This starts to get into the same realm of the views
as to whether the edge reference is useful by the consumer or not (e.g. basic\_ vs. regular versions).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{out} is an operator for setting the resulting Jaccard coefficient. This function is expected to be of the form \lstinline{out(vertex_id_t<G> uid, vertex_id_t<G> vid, edge_t<G> uv, T val)}.
            \end{itemize}
      \pnum\effects 
            \begin{itemize}
                  \item
                        For every pair of neighboring vertices \lstinline{(uid, vid)}, the function \lstinline{out} is called, passing the vertex ids, 
                        the edge \lstinline{uv} between them, and the calculated Jaccard coefficient.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Minimum Spanning Tree}
%\andrew{Simplified ``driver'' for these also?}

\subsection{Kruskal Minimum Spanning Tree}
Find the minimum weight spanning tree of a graph using Kruskal's algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|)$
            }
      & \textbf{Directed?} Yes & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} No & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=8]{D3128_Algorithms/src/mst.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{e} is an \lstinline{edgelist}.
                  \item
                        \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{range_value_t<EL>::value_type} 
                        which returns a bool.
            \end{itemize}
      \pnum\effects 
            \begin{itemize}
                  \item
                        Edgelist \lstinline{t} contains edges representing a spanning tree or forest, which minimize the comparison operator. 
                        When \lstinline{compare} is \lstinline{<}, \lstinline{t} represents a minimum weight spanning tree.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Prim Minimum Spanning Tree}
Find the minimum weight spanning tree of a graph using Prim's algorithm.

\phil{Use general form of dijkstra's shortest path?}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|P{0.20\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|log|V|)$
            }
      & \textbf{Directed?} No & \textbf{Cycles?} No & \textbf{Throws?} No \\
      & \textbf{Multi-edge?} No & \textbf{Self-loops} No & \\
\hline
\end{tabular}
%\caption{Algorithm Example}
\label{tab:algo_example}
\end{table}

{\small
      \lstinputlisting[firstline=13,lastline=29]{D3128_Algorithms/src/mst.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      %\pnum\effects
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= seed < num_vertices(g)}.
                  \item
                        Size of \lstinline{weight} and \lstinline{predecessor} is greater than or equal to \lstinline{num_vertices(g)}.
                  \item
                        \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{edge_value_t<G>} which returns a bool.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{predecessor[v]} is the parent vertex of \lstinline{v} in a tree rooted at \lstinline{seed} and \lstinline{weight[v]} is the value of the edge between \lstinline{v} and \lstinline{predecessor[v]} in the tree. When \lstinline{compare} is \lstinline{<} and \lstinline{init_dist==+inf}, \lstinline{predecessor} represents a minimum weight spanning tree.
                  \item
                        If \lstinline{predecessor} and \lstinline{weight} are not initialized by user, and the graph is not fully connected, \lstinline{predecessor[v]} and \lstinline{weight[v]} will be undefined for vertices not in the same connected component as \lstinline{seed}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\andrew{I've tagged the algorithms below as Tier 2 or Tier 3 -- denoting whether they should be done right now or done later or done much later.}

\andrew{I've used NetworkX as inspiration for organization.  Oddly, NetworkX only has DFS as an adaptor (view).}
\phil{If the use of Yield is any indicator, then NetworkX implements topological sort as adaptor also.}




\begin{comment}

      %Algorithms with [TBD] are candidates to consider but having been decided for being in the paper
      %We are targeting the paper to be under 50pp
      All algorithms are customization points.

      \phil{Algorithms marked [TBD] are provisional and may be moved to a separate proposal to keep the size of this proposal manageable}

      \subsection{Dijkstra's Shortest Paths and Shortest Distances}
      %Dijkstra's algorithm \cite{REF_} is a single-source, shortest paths algorithm for non-negative weights. It finds the shortest paths
      %and their weighted distances to all vertices connected to a single seed vertex.

      \begin{lstlisting}
      template <adjacency_list G, class DistanceValue>
      auto dijkstra_infinite_distance() {
      return numeric_limits<DistanceValue>::max();
      }

      template <adjacency_list              G,
            ranges::random_access_range Distance,
            ranges::random_access_range Predecessor,
            class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
            queueable Q = 
                  priority_queue<
                        weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                        vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                        greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
      requires ranges::random_access_range<vertex_range_t<G>> &&                  //
            integral<vertex_id_t<G>> &&                                           //
            is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
            convertible_to<vertex_id_t<G>, ranges::range_value_t<Predecessor>> && //
            edge_weight_function<G, EVF>
      constexpr void dijkstra_shortest_paths(
            G&&            g,           // graph
            vertex_id_t<G> seed,        // starting vertex_id
            Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
            Predecessor&   predecessor, // out: predecessor[uid] of vertex_id uid in path
            EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                          { return ranges::range_value_t<Distance>(1); },
            Q              q = Q()
            );
      \end{lstlisting}

      \begin{table}[h!]
            %\begin{center}
            %\resizebox{\textwidth}{!}
            {\begin{tabular}{l l}
                        \hline
                        \textit{Complexity}     & O(V log(V)).                                                                                                                                                  \\
                                                & Additional time will be required to pre-extend  or initialize the \tcode{distance} range by the caller.                                                       \\
                                                & Additional time may also be required to pre-extend \tcode{predecessor}.                                                                                       \\
                        \andrew{O((|E| + |V|)log(|V|) or O(|E| + |V|log(|V|).  Initializing distance and predecessor are O(|V|) so don't change the complexity.}
                        \hline
                        \textit{Constraints}    & Values returned by \tcode{weight_fn} must be non-negative.                                                                                                    \\
                        \hline
                        \textit{Preconditions}  & \tcode{seed >= 0                                                                                                               &  & seed < size(vertices(g))} \\
                                                & \tcode{size(distance) >= size(vertices(g))}; caller must pre-extend with \tcode{dijkstra_infinite_distance()}                                                   \\
                                                & \tcode{size(predecessor) >= size(vertices(g))}; caller must pre-extend                                                                                        \\
                                                & \tcode{distance[i] = dijkstra_infinite_distance()} for \tcode{i < size(vertices(g))}                                                                           \\
                        \hline
                        \textit{Postconditions} & \tcode{distance[seed] == 0}                                                                                                                                   \\
                                                & \tcode{predecessor[seed] == seed}.                                                                                                                            \\
                        \hline
                        \textit{\effects}       & \tcode{distance[uid]} will be the shortest, weighted distance of vertex\_id \tcode{uid} from \tcode{seed}.                                                    \\
                                                & If \tcode{uid} is not connected to \tcode{seed} by any edges then it will have a value of \tcode{dijkstra_infinite_distance()}.                                \\
                                                &                                                                                                                                                               \\
                                                & \tcode{predecessor[uid]} will have the preceding vertex\_id of \tcode{uid} in the weighted shortest path to \tcode{seed}                                      \\
                                                & when \tcode{distance[uid] != dijkstra_infinite_distance()}.                                                                                                    \\
                        \hline
                  \end{tabular}}
            %\caption{\tcode{incidence} View Functions}
            %\label{tab:incidence}
            %\end{center}
      \end{table}

      \phil{Describe the pros and cons of different kinds of queues}

      The default weight function \tcode{weight_fn} returns a value of 1. When that is used, \tcode{distance[uid]} will have the shortest number of edges
      between vertex \tcode{uid} and vertex \tcode{seed}. The distance from \tcode{seed} to itself is zero.

      If the caller wishes to use a different queue other than \tcode{priority_queue}, the queue will need to have elements of \tcode{weighted_vertex}
      which is used internally by the algorithm.
      \begin{lstlisting}
      template <class G, class W>
      requires is_default_constructible_v<vertex_id_t<G>> && is_default_constructible_v<W>
      struct weighted_vertex {
      vertex_id_t<G> vertex_id = vertex_id_t<G>();
      W              weight    = W();
      constexpr auto operator<=>(const weighted_vertex&) const noexcept; // compare vertex_id
      };
      \end{lstlisting}

      The \tcode{dijkstra_shortest_distances} function is the same as \tcode{dijkstra_shortest_paths} except that it doesn't include
      the \tcode{predecessor} parameter.
      \begin{lstlisting}
      template <adjacency_list              G,
            ranges::random_access_range Distance,
            class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
            queueable Q = 
                  priority_queue<
                        weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                        vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                        greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
      requires ranges::random_access_range<vertex_range_t<G>> &&                  //
            integral<vertex_id_t<G>> &&                                           //
            is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
            edge_weight_function<G, EVF>
      constexpr void dijkstra_shortest_distances(
            G&&            g,           // graph
            vertex_id_t<G> seed,        // starting vertex_id
            Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
            EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                          { return ranges::range_value_t<Distance>(1); },
            Q              q = Q()
            );
      \end{lstlisting}

      \subsection{[TBD] Delta Stepping Shortest Paths}
      %The  algorithm \cite{REF_} ...

      \subsection{Bellman-Ford Shortest Paths}
      %The Bellman-Ford algorithm \cite{REF_} ...

      \subsection{[TBD] Shortest Paths}
      (Overloads to select appropriate algorithm based on inputs)

      \subsection{Connected Components}
      %Connected components \cite{REF_} ...

      \subsection{Strongly Connected Components}
      %Strongly connected components \cite{REF_} ...

      \subsection{Biconnected Components}
      %Biconnected components \cite{REF_} ...

      \subsection{Articulation Points}
      %Articulation points \cite{REF_} ...

      \subsection{Minimum Spanning Tree}
      %Minimum Spanning Tree \cite{REF_} ...

      \subsection{[TBD] Betweenness Centrality}
      \subsection{[TBD] Triangle Count}
      \subsection{[TBD] Subgraph Isomorphism}
      \subsection{[TBD] Kruskal Minimum Spanning Tree}
      \subsection{[TBD] Prim Minimum Spanning Tree}
      \subsection{[TBD] Louvain (Community Detection)}
      \subsection{[TBD] Label propagation (Community Detection)}

\end{comment}
