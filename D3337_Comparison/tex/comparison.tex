\clearpage

For the algorithms in this paper, the reference implementation of the proposed graph library is referred to as \stdgraph~\cite{REF_stdgraph_library}. A recent library that this implementation is based on is referred to as \nwgraph~\cite{REF_nwgraph_paper,REF_nwgraph_library}.  \bgl is used to refer to algorithms using the Boost Graph Library~\cite{BGL}.  

%% \chapter{Comparison}


\section{Syntax Comparison} \label{syntax}
In this section, we provide a usage syntax comparison of several 
graph algorithms in Tier 1 of P3128 against the equivalent implementations in 
\bgl and the more recent \nwgraph.
These algorithms are breadth-first search (BFS, Figure~\ref{fig:bfssyntax}),
connected components (CC, Figure~\ref{fig:ccsyntax}),
single source shortest paths (SSSP, Figure~\ref{fig:ssspsyntax}),
and triangle counting (TC, Figure~\ref{fig:tcsyntax}).
We take these algorithms from the GAP Benchmark Suite~\cite{beamer2015gap}.
We defer to later sections any discussion of
underlying implementation details and resulting performance.

Unlike \bgl, \stdgraph does not specify edge direction as a graph property.
If a graph in \stdgraph implemented by \tcode{container::compressed\_graph}
is undirected, then it will contain distinct edges in both directions.
\bgl has a \tcode{boost::graph::undirectedS} property
which can be used in the \tcode{boost::graph::adjacency\_matrix} class
to specify an undirected graph, but
not in the \tcode{boost::graph::compressed\_sparse\_row\_graph} class.
Thus in Figures~\ref{fig:bfssyntax}-\ref{fig:tcsyntax}, the \bgl graph type 
always includes \tcode{boost::graph::directedS}.
Similar to \stdgraph, undirected graphs must contain the edges in both directions.

Intermediate data structures (e.g., edge lists) will be needed
to construct the compressed graph structures.
In order to focus on the differences in algorithm syntax, we omit
code which populates the graph data structures.
In the following subsections, we address the syntax differences for each of
these algorithms.

\begin{figure}[ht]
\noindent\begin{minipage}{.492\textwidth}
\subcaptionbox{ \bgl }
{\small
      \lstinputlisting{D3337_Comparison/src/bgl_bfs.hpp}
}
\end{minipage}\hfill
\begin{minipage}{.492\textwidth}
\subcaptionbox{ \stdgraph }
{\small
      \lstinputlisting{D3337_Comparison/src/stdgraph_bfs.hpp}
}
\end{minipage}
\caption{Breadth-First Search Syntax Comparison}
\label{fig:bfssyntax}
\end{figure}
\begin{figure}[ht]
\noindent\begin{minipage}{.492\textwidth}
\subcaptionbox{ \bgl }
{\small
      \lstinputlisting{D3337_Comparison/src/bgl_cc.hpp}
}
\end{minipage}\hfill
\begin{minipage}{.492\textwidth}
\subcaptionbox{ \stdgraph }
{\small
      \lstinputlisting{D3337_Comparison/src/stdgraph_cc.hpp}
}
\end{minipage}
\caption{Connected Components Syntax Comparison}
\label{fig:ccsyntax}
\end{figure}

\begin{figure}[ht]
\noindent\begin{minipage}{.492\textwidth}
\subcaptionbox{ \bgl }
{\small
      \lstinputlisting{D3337_Comparison/src/bgl_sssp.hpp}
}
\end{minipage}\hfill
\begin{minipage}{.492\textwidth}
\subcaptionbox{ \stdgraph }
{\small
      \lstinputlisting{D3337_Comparison/src/stdgraph_sssp.hpp}
}
\end{minipage}
\caption{Single Source Shortest Paths Syntax Comparison}
\label{fig:ssspsyntax}
\end{figure}

\begin{figure}[ht]
\noindent\begin{minipage}{.492\textwidth}
\subcaptionbox{ \bgl }
{\small
      \lstinputlisting{D3337_Comparison/src/bgl_tc.hpp}
}
\end{minipage}\hfill
\begin{minipage}{.492\textwidth}
\subcaptionbox{ \stdgraph }
{\small
      \lstinputlisting{D3337_Comparison/src/stdgraph_tc.hpp}
}
\end{minipage}
\caption{Triangle Counting Syntax Comparison}
\label{fig:tcsyntax}
\end{figure}

\begin{figure}[ht]
\noindent\begin{minipage}{.492\textwidth}
\subcaptionbox{ \bgl }
{\small
      \lstinputlisting{D3337_Comparison/src/bgl_tc_low.hpp}
}
\end{minipage}\hfill
\begin{minipage}{.492\textwidth}
\subcaptionbox{ \stdgraph }
{\small
      \lstinputlisting{D3337_Comparison/src/stdgraph_tc_low.hpp}
}
\end{minipage}
\caption{Triangle Counting Underlying Implementation Syntax Comparison}
\label{fig:tclowsyntax}
\end{figure}

\subsection{Breadth-First Search}
Figure~\ref{fig:bfssyntax} compares the simplest \bgl
BFS visitor against the range-based-for loop implementation of \stdgraph.
BFS is often described as a graph algorithm, though a BFS traversal
by itself does not actually perform any task.
In reality, it is a data access pattern which specifies an order
vertices and edges should be processed by some higher level algorithm.
\bgl provides a very customizable interface to this
data access pattern through the use of visitors which allows users
to customize function calls during BFS events.
For example \tcode{discover\_vertex} is called when a vertex is encountered for the
first time; \tcode{examine\_vertex} is called when a vertex is popped from the queue;
\tcode{examine\_edge} is called on each edge of a vertex when it is discovered, etc.
Figure~\ref{fig:bfssyntax}(a) demonstrates the usage of a BFS visitor
\tcode{record\_predecessors} which is called upon event \tcode{on\_tree\_edge}
during BFS traversal to store the parent node of every discovered vertex.

This capability is very powerful but often cumbersome if the BFS traversal
simply requires vertex and edge access upon visiting.
For this reason \stdgraph provides a simple, range-based-for loop BFS traversal
called a view.
Figure~\ref{fig:bfssyntax}(b) demonstrates how the visited edge \tcode{uv} and incident vertices \tcode{uid} and \tcode{vid} are exposed to the library user to store the parent information explicitly.
The authors of this proposal acknowledge that some power users still want
the full customization provided by visitors,
and we plan to add them to this proposal.

Also note \bgl often requires the use of vertex descriptors to uniquely
identify vertices, as shown by the \tcode{graph\_traits<G>::vertex_descriptor}
type in Figure~\ref{fig:bfssyntax}(a).
Algorithms written using \stdgraph use a unique vertex id, as shown by the
\tcode{vertex\_id\_t<G>} type in Figure~\ref{fig:bfssyntax}(b).
This same difference is seen in the algorithms that follow.

\subsection{Connected Components}
There is very little difference in the connected component interfaces.

\scott{There is at least one difference.  The requirements on the container
that holds the component information.  \bgl seems to require a C-array or at
the very least a pointer like thing to contiguous memory.  What exactly does
\stdgraph require?  What is the concept?  Is it more flexible than the BGL interface?}

\subsection{Single Source Shortest Paths}
Of the four algorithms discussed here, only SSSP makes use of an
edge property associated with the input graph, the distance used
to compute shortest paths.
The algorithm computes for
every vertex (1) a distance from the start vertex, and (2) a predecessor
vertex along the shortest path.
In Figure~\ref{fig:ssspsyntax} we see that \bgl requires
property maps to lookup edge and vertex properties.
These property maps are tightly coupled with the graph data structures.
With \stdgraph, we propose properties be stored external to the graph.
For edge properties we provide a weight lambda function to the algorithm
to lookup distance from the \tcode{edge\_reference\_t}.

\subsection{Triangle Counting}
\bgl does not provide a triangle counting algorithm
similar to the one proposed in \stdgraph.
The code example in Figure~\ref{fig:tcsyntax}(a) is representative of what is
currently available in \bgl; it iterates through the vertices,
counting the number of triangles
incident on every vertex, and adjusts for overcounting at the end.

\stdgraph provides a much more efficient implementation with a high level
interface shown in Figure~\ref{fig:tcsyntax}(b).
The underlying \stdgraph implementation performs a set intersection
of the neighbor list of vertices $u$ and $v$, only if $v$ is a neighbor of $u$.
This approach  requires the edges of a vertex to be stored
in lexicographic order (by target vertex id), and to only contain successor
edges (target vertex id greater than source vertex id). The latter
requirement is equivalent to the graph only containing the upper triangular
portion of the adjacency matrix.
Then the set intersection is limited to neighbors with vertex ids greater
than $u$ and $v$, avoiding duplicate counting.

In fairness to \bgl, especially for the purposes of the performance comparison
in Section \ref{performance}, we implement TC in \bgl using the same set
intersection approach used inside \stdgraph.
Figure~\ref{fig:tclowsyntax} compares the underlying implementation syntax
for each library.
Note again for \bgl the need to go through vertex descriptors to access the out
edges of a vertex while \stdgraph uses a vertex id.
\kevin{Say something about \tcode{incidence\_iterator} and \tcode{end(edges(g,uid))}? The while condition is different, think this has to be the case, not fully sure why \tcode{i != ie} doesn't work for BGL, say something?}

\clearpage

\section{Performance Comparison} \label{performance}
\subsection{Experimental Setup}
To evaluate the performance of this proposed library, we compare its reference implementation
(\stdgraph) against \bgl and \nwgraph on a subset of the GAP Benchmark Suite~\cite{beamer2015gap}.
This comparison includes four of the five GAP algorithms that are in the tier 1 algorithm list of this proposal:
breadth-first search (BFS), connected components (CC), single-source shortest paths (SSSP), 
and triangle counting (TC).  The performance of \nwgraph on the algorithms and a comparison to other
graph frameworks was carried out in~\cite{gapbs_2023}.
Table~\ref{tab:gap_graphs} summarizes the graphs specified by the GAP benchmark.
These graphs were chosen with a variety of degree distributions and diameters, and to be large (with edge counts into the billions) but still fit on shared memory machines.

We compare to \bgl because it the commonly used sequential C++ graph library as described above.
\nwgraph is the direct predecessor of \stdgraph, with many of the \nwgraph authors contributing to this library proposal and the \stdgraph reference implementation.
It was implemented with many of the ideas of this proposal in mind, e.g. graphs as a range of ranges and generic algorithms that support any data structure that meet the concept requirements.
Since the two implementations are based on similar ideas, we expect similar experimental performance, and include \nwgraph to verify \stdgraph does not introduce any performance overhead.

\begin{table}[h!]
\centering
\begin{tabular}{c c c c c c c}
Name & Description & \#Vertices & \#Edges & Degree & (Un)directed & References \\
     &             & (M)        & (M)     & Distribution & & \\\hline
road & USA road network & 23.9 & 57.7 & bounded & undirected & \cite{dimacs9th}\\\hline
Twitter & Twitter follower links & 61.6 & 1,468.4 & power & directed & \cite{Twitter}\\\hline
web & Web crawl of .sk domain & 50.6 & 1,930.3 & power & directed & \cite{LAW1}\\\hline
kron & Synthetic graph & 134.2 & 2,111.6 & power & undirected & \cite{Graph500} \\\hline
urand & Uniform random graph & 134.2 & 2,147.5 & normal & undirected & \cite{Erdos}\\\hline
\end{tabular}
\caption{Summary of GAP Benchmark Graphs}
\label{tab:gap_graphs}
\end{table}

The \nwgraph authors published a similar comparison to BGL in which they
demonstrated performance improvement of \nwgraph over BGL~\cite{REF_nwgraph_paper}.
To simplify experimental setup, we rerun these new experiments using the same machine used in that paper,
(compute nodes consisting of two Intel® Xeon® Gold 6230 processors, each with 20 physical cores running at 2.1 GHz,
and 188GB of memory per processor).
All three implementations were compiled into a single experimental driver to ensure uniform compiler setup (gcc 13.2 using \tcode{-Ofast -march=native} compilation flags.)
Additionally any graph preprocessing such as symmetricization (for undirected algorithms) or vertex relabeling are guaranteed to be the same for all three implementations.

\subsection{Experimental Analysis}

Table~\ref{tab:performance_numbers} summarizes our GAP benchmark results for \stdgraph compared to \bgl and \nwgraph.
In addition to runtime, the table contains the number of connected components and the number of
triangles for each graph as this is helpful for understanding performance.
The below subsections consider each GAP algorithm, describe the specific algorithm implementation(s)
tested for each library, and examine the performance results.

\begin{table}[h!]
\centering
\begin{tabular}{ c l c c c c c c }
Algorithm & Library & Variant & road & twitter & kron & web & urand \\
\hline
\multirow{3}{*}{BFS} & \bgl & & 0.99s & 7.82s & 17.40s & 4.13s & 59.05s \\
& \nwgraph  & & 0.88s & 9.08s & 25.04s & 2.09s & 68.18s \\
& \stdgraph & & 0.92s &  7.00s & 15.93s & 2.61s & 55.13s \\
\hline
\multirow{3}{*}{CC} & & & 1 CC & 19.9M CC & 71.2M CC & 123 CC & 1 CC\\
& \bgl & DFS-based & 1.30s & 32.03s & 71.38s & 11.93s & 94.80s \\
& \stdgraph & DFS-based & 0.76s & 27.87s & 41.21s & 6.64s & 64.87s \\
& \nwgraph  & Afforest & 1.15s & 6.09s & 28.42s & 3.29s & 28.73s \\
& \stdgraph & Afforest & 0.97s & 5.85s & 23.37s & 3.16s & 33.84s \\
\hline
\multirow{3}{*}{SSSP} & \bgl & Dijkstra & 3.97s & 45.24s & OOM & 24.86s & OOM \\
& \nwgraph  & Dijkstra & 3.62s & 95.78s & 313.96s & 30.66s & 356.11s \\
& \stdgraph & Dijkstra & 4.06s & 104.38s & 348.72s & 33.77s & 387.75s \\
& \nwgraph & Delta\-Stepping & 1.49s & 24.48s & 74.43s & 12.53s & 103.97s \\
\hline
\multirow{3}{*}{TC} & & & 439K T & 34.8B T & 107B T & 84.9B T & 5.38K T\\
& \bgl & $\frac{1}{6} tr(A^3)$ & 1.34s & >24H & >24H & >24H & 4425.54s \\
& \bgl & Upper triangular & 0.61s & 1672.71s & 8346.70s & 251.78s & 405.37s \\
& \nwgraph  & Upper triangular & 0.20s & 567.97s & 2962.32s & 107.85s & 152.52s \\
& \stdgraph & Upper triangular & 0.17s &  524.68s & 2683.41s & 71.10s & 128.32s \\
\hline
\end{tabular}
\caption{GAP Benchmark Performance: Time for GAP benchmark algorithms is shown for \bgl, \nwgraph, \stdgraph}
\label{tab:performance_numbers}
\end{table}

\subsubsection{Breadth-First Search}
All implementations of BFS use a sequential push variant that one could find in a textbook
(no direction optimization or parallel processing of frontier).
As mentioned in Section \ref{syntax}, \bgl contains support for visitors which is not available
in \nwgraph or the version of \stdgraph being tested here.

BFS results are competitive between the libraries, with the \stdgraph implementation achieving the fastest time on all but the road graph.
\nwgraph has noticably worse performance on kron and urand.
\bgl underperforms on web by 2x but this run only takes around 4s.

\subsubsection{Connected Components}
The \nwgraph implementation of CC is based on the Afforest \cite{sutton2018optimizing} algorithm.
\bgl does not provide an Afforest variant.
Instead, \bgl implements a simple depth-first search based CC algorithm.
\stdgraph contains implementations of both.
However, the \stdgraph implementation of Afforest does not contain support for parallel execution
policies which \nwgraph does, and does not contain the overhead of atomics.

It is likely that other researchers implementing the GAP benchmark use CC to refer
to weakly connected components of a directed graph.
As the DFS based CC implmentation of \bgl and \stdgraph assumes an undirected graph,
we make all graphs undirected before running these experiments.

Comparing the two DFS based implementations, \stdgraph has consistently better performance, up to 2x, over the \bgl implementation.
The Afforest implementations outperform the DFS based implementations.
Of the two Afforest implementations, \stdgraph is slightly faster but this is reasonable considering
it does not have the parallel overhead of the \nwgraph implementation.

\subsubsection{Single Source Shortest Paths}
For this SSSP comparison, we test a Dijkstra implementation for each of the libraries.
\nwgraph contains multiple Dijkstra implementations, but we use the simplest one which
is taken directly from the \nwgraph benchmark directory.
Even though \nwgraph contains an implementation of Dijkstra,
the SSSP results in \cite{REF_nwgraph_paper} were based on delta-stepping.
In fairness to \nwgraph, we also include delta-stepping performance for \nwgraph 
as this was highly tuned compared to \nwgraph's Dijkstra implementation.
However, this implementation contains \tcode{std::for\_each} and is therefore not sequential.

The GAP specification for SSSP only requires that the algorithm compute the shortest distance
to every vertex, not the shortest path.
Each library has a variant of Dijkstra that only computes shortest distances which we use for these experiments.

SSSP results are more mixed, with superior performance for \bgl on twitter and web,
while \bgl fails by running out of memory on kron and urand.
The edge distances required for SSSP make this a more memory intensive algorithm
than the other GAP algorithms.
The 2x performance of \bgl over \nwgraph and \stdgraph on twitter is notable and calls for further
investigation.
\kevin{See if we can get kron numbers for \bgl by doing more memory cleanup}

\subsubsection{Triangle Counting}

\nwgraph and \stdgraph contain similar implementations of TC 
that perform a set intersection of the neighbor list of vertices.
This is discussed in Section \ref{syntax} and the \stdgraph code is shown
in Figure~\ref{fig:tclowsyntax}(b).
As noted in Section \ref{syntax}, the na\"ive \bgl TC implementation shown in Figure~\ref{fig:tcsyntax}(a) is very inefficient.
For these performance experiments we include both the inefficient \bgl approach, and our own
\bgl set intersection implementation shown in Figure~\ref{fig:tclowsyntax}(b).

TC performance from our na\"ive \bgl implementation
is far slower than the adjacency matrix set intersection used by \nwgraph
and \stdgraph.
Since the same triangle is counted six times in \bgl,
one can expect at least that much of a slowdown; however, the slowdown
is often much worse likely due to poor memory access patterns.
The \bgl implementation of the set intersection approach is much faster
than the na\"ive approach, but is still significantly slower than the
\nwgraph or \stdgraph implementations, up to a factor of 3x on road and kron.
It is unclear if this is a fundamental limitation of \bgl or our implementation could be
further optimized.
\stdgraph consistently outperforms \nwgraph, up to 1.5x on web.
This is surprising given the similarity of the implementations, and could indicate more
efficient data access for the \stdgraph graph data structure.

\section{Memory Allocation}

Unlike existing STL algorithms, the graph algorithms in the \stdgraph reference
implementation often need to allocate their own temporary data structures.
Table~\ref{tab:internalmem} records the internal memory allocations
required for \stdgraph's implementation of the GAP Benchmark algorithms
where relevant.
It is important to note that the memory usage is not prescribed
by the algorithm interface in P3128, and is ultimately determined by the
library implementer.
Some memory use, such as the queues in BFS and SSSP, will
probably be common to most implementations.
However, the color map in BFS and the reindex map in CC
(used to ensure the resulting component indices are contiguous)
could potentially be avoided.

\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c |}
\hline
Algorithm & Required Internal Data & Max Size \\\hline
BFS       & queue          & $O(|V|)$ \\
          & color map      & V \\\hline
CC        & reindex map    & $O(|components|)$ \\\hline
SSSP      & priority queue & $O(|E|)$\\\hline
TC        & None           & N\/A\\
\hline
\end{tabular}
\caption{Internal Memory Allocations of GAP Benchmark Algorithm Implementations in \stdgraph}
\label{tab:internalmem}
\end{table}
