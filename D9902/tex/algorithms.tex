%% \chapter{Algorithms}

\section{Algorithm Selection} \label{other_algo}

When determining the algorithms to propose we split them into different tiers. Tier 1 algorithms are included
in this proposal. The algorithms selected are a result of balancing a few things:
\begin{itemdescr}
\begin{itemize}
      \item Include a rich enough set of algorithms for the library to be useful.
      \item Include algorithms with well-defined functionality and agreed-upon algorithmic description.
      \item Don't include so many that the proposal will get bogged down for years and years.
\end{itemize}
\end{itemdescr}

\subsection{Tier 1 Algorithms}
\begin{multicols}{3}
      \emph{Shortest Paths}
      \begin{itemize}
            %\item Shortest paths (driver interface)
            \item Breadth-First search
            \item Dijkstra's algorithm
            \item Bellman-Ford
      \end{itemize}
      \emph{Clustering}
      \begin{itemize}
            \item Triangle counting
      \end{itemize}
      \emph{Communities}
      \begin{itemize}
            \item Label propagation
      \end{itemize}
\columnbreak
      \emph{Components}
      \begin{itemize}
            \item Articulation points
            \item Connected components
            \item Biconnected components
            \item Kosaraju's Strongly CC
            \item Tarjan's Strongly CC
      \end{itemize}
      \emph{Directed Acyclic Graphs}
      \begin{itemize}
            \item Topological sort
      \end{itemize}
\columnbreak
      \emph{Maximal Independent Set}
      \begin{itemize}
            \item Maximal independent set
      \end{itemize}
      \emph{Link Analysis}
      \begin{itemize}
            \item Jaccard coefficient
      \end{itemize}
      \emph{Minimal Spanning Tree}
      \begin{itemize}
            \item Kruskal's MST
            \item Prim's MST
      \end{itemize}

\vfill\null
\end{multicols}

Shortest Paths and Topological Sort are all single source with multiple targets.

\subsection{Other Algorithms}
Additional algorithms that were considered but not included in this proposal are identified in Table \ref{tab:other_algorithms}. 
It is assumed that future proposals will include them, with a recommendation of each Tier being in its own proposal.
Tier X algorithms are variations of shortest paths algorithms that complement the Single Source, Multiple Target algorithms 
in this proposal.

\phil{We may want to revisit the Driver idea in the future after we have more algorithms.}
%The Shortest Paths Driver is an idea of having a unified interface that chooses the best Shortest Path algorithm
%based on characteristics like non-negative edge weight, multi-threading, etc.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l|l|l}
\hline
    \textbf{Tier 2} & \textbf{Tier 3} & \textbf{Tier X} \\
\hline
    All Pairs Shortest Paths & Jones Plassman & Single Source, Single Target: Shortest Paths Driver\\
    Floyd-Warshall & Cores: k-cores & Single Source, Single Target: BFS \\
    Johnson & Cores: k-truss & Single Source, Single Target: Dijkstra \\
    Centrality: Betweenness Centrality & Subgraph Isomorphism & Single Source, Single Target: Bellman-Ford \\
    Coloring: Greedy & & Single Source, Single Target: Delta Stepping \\
    Communities: Louvain & &  \\
    Connectivity: Minimum Cuts & & Multiple Source: Shortest Paths Driver \\
    Transitive Closure & & Multiple Source: BFS \\
    Flows: Edmunds Karp & & Multiple Source: Dijkstra \\
    Flows: Push Relabel & & Multiple Source: Bellman-Ford \\
    Flows: Boykov Kolmogorov & & Multiple Source: Delta Stepping \\
    Link Analysis: Adamic-Adar Index & &  \\
    Pathfinding: A* & & Multiple Source, Single Target: Shortest Paths Driver\\
    Best-first search & & Multiple Source, Single Target: BFS \\
    & & Multiple Source, Single Target: Dijkstra \\
    & & Multiple Source, Single Target: Bellman-Ford \\
    & & Multiple Source, Single Target: Delta Stepping \\
\hline
\end{tabular}}
\caption{Other Algorithms}
\label{tab:other_algorithms}
\end{center}
\end{table}

\andrew{All Pairs: Tier 2?  People bring this up alot -- but it is very expensive in terms of computation and memory.}
\phil{If it's useful to enough people it should be included. Users can make their own determination of whether they want to use it, based on the cost.}

\andrew{Note that NetworkX also specifies single source single target and multiple source versions of the shortest paths algorithms.  
BGL does not have these (nor NWGraph).  We should discuss whether or not to consider those and whether or not to make them Tier 1, 2, 3, or infinity.}
\phil{I think we're beyond considering these for the initial proposal. They can be added in the future, unless we're told otherwise.}

\phil{The same variations for Shortest Paths algorithms can also be useful for topological sort.}

\phil{Many algorithms allocate memory. Should we include a [PMR] allocator argument?}

% Floyd-Warshall $\mathcal{O}(N^2)$}
% Johnson $\mathcal{O}(N^2)$}

\section{Algorithm Concepts}

%\andrew{Need to develop this ala CppCon 2021 talk.}

The abstraction that is used for describing and analyzing almost all graph algorithms is the adjacency list.  Naturally then implementations of graph algorithms in C++ will operate on a data structure representing an adjacency list.  And generic algorithms will be written in terms of concepts that capture the essential operations that a concrete data structure must provide in order to be used as an abstraction of an adjacency list.

Most fundamentally (as illustrated above), an adjacency list is a collection of vertices, each of which has a collection of outgoing edges.  In terms of existing C++ concepts, we can consider an adjacency list to be a range of ranges (or, more specifically, a random access range of forward ranges).  The outer range is the collection of vertices, and the inner ranges are the collections of outgoing edges.

%\andrew{Is it better to list the concepts here or forward reference them?  Kind of a circularity.  But maybe the sequence of concepts - algorithms - concrete data types is the right one.  OTOH, std::ranges use ordering overview library-concepts-containers-algorithms.  Since a graph is a range of ranges, maybe we should follow that.}

%\phil{I think this is a good place, just before they're used in the text for this section.}
% Additional concepts used by algorithms.

\begin{lstlisting}
template <class G, class WF, class DistanceValue, class Compare, class Combine>
concept basic_edge_weight_function = // e.g. weight(uv)
      is_arithmetic_v<DistanceValue> && 
      strict_weak_order<Compare, DistanceValue, DistanceValue> &&
      assignable_from<add_lvalue_reference_t<DistanceValue>,
            invoke_result_t<Combine, DistanceValue, invoke_result_t<WF, edge_reference_t<G>>>>;

template <class G, class WF, class DistanceValue>
concept edge_weight_function = // e.g. weight(uv)
      is_arithmetic_v<invoke_result_t<WF, edge_reference_t<G>>> &&
      basic_edge_weight_function<G,
                                  WF,
                                  DistanceValue,
                                  less<DistanceValue>,
                                  plus<DistanceValue>>;
\end{lstlisting}

\begin{comment}
      \phil{Queueable isn't being used.}
      \begin{lstlisting}
      // queueableQ can represent std::queue and std::priority\_queue
      template <class Q>
      concept queueable = requires(Q&& q, Q::value_type value) {
      Q::value_type;
      Q::size_type;
      Q::reference;

      {q.top()};
      {q.push(value)};
      {q.pop()};
      {q.empty()};
      {q.size()};
      };
      \end{lstlisting}
\end{comment}



\section{Shortest Paths}


\begin{comment}
      \subsection{Driver Interface}

      \andrew{I am not sure we should have the unified interface.  We need to be more parsimonious in our interfaces.  Users can read the documentation for which algorithms to use.  And, if they are using graph algorithms, we should assume a certain level of knowledge about graph algorithms.  OTOH, it is only a handful of algorithms.}

      \andrew{I am also not sure we should have ``shortest distance'' variants.  That doubles the number of functions in the interface.
            For each function we have shortest paths, s-t paths, multi-source paths, parallel = 6X variants for each base function.  If we add shortest distances, that will make 12X.  OTOH, we could consider not having s-t paths or not having multi-source paths -- which would leave 4X for each base function.  However, I think people will want s-t and multi-source.
      }
      \phil{\tcode{dijkstra_shortest_distances} includes predecessor and distances, so excluding \tcode{dijkstra_shortest_distances} won't impact 
      the user much.}


      {\small
            \lstinputlisting{D9902/src/shortest_paths.hpp}
      }

      \andrew{The variety of algorithms was inspired by networkx....  Which also had ``distance'' variants.}

      \phil{I assume \tcode{adjacency_list_graph} is the same as our \tcode{adjacency_list}. \tcode{bidirectional_adjacency_list_graph} is new; what to do with it?}
\end{comment}


\subsection{Unweighted Shortest Paths}

\subsubsection{Breadth-First Search, Single Source, Initialization}

{\small
      \lstinputlisting{D9902/src/breadth_first_search_helpers.hpp}
}

\begin{itemdescr}
      \effects
      \begin{itemize}
            \item
                  Each \lstinline{predecessors[i]} is initialized to \lstinline{i}.
      \end{itemize}
\end{itemdescr}


\subsubsection{Breadth-First Search, Single Source}
Compute the breadth-first path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}((|E| + |V|)\log{|V|})$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes \\
\hline
\end{tabular}
%\caption{Dijkstra Single Source Summary}
\label{tab:dijkstra_ss_summary}
\end{table}
Note that complexity may be $\mathcal{O}(|E| + |V|\log{|V|)}$ for certain implementations.

{\small
      \lstinputlisting{D9902/src/breadth_first_search.hpp}
}

\begin{itemdescr}
      %\pnum\mandates
      % \pnum
\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_breadth_first_search}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_breadth_first_search}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the lowest number of edges from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{breadth_first_search_invalid_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      %\pnum\throws \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(graph)}.  \\
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}


\subsection{Weighted Shortest Paths}

\subsubsection{Shortest Paths Initialization}

{\small
      \lstinputlisting{D9902/src/shortest_paths_helpers.hpp}
}

\begin{itemdescr}
      \pnum
      \effects:
            \begin{itemize}
                  \item
                        \lstinline{init_shortest_paths(distances)} sets all elements in \lstinline{distance} to \lstinline{shortest_path_invalid_distance()}
                  \item
                        \lstinline{init_shortest_paths(distances,predecessors)} does the same as \lstinline{shortest_path_invalid_distance(distances)}
                        and sets \lstinline{predecessors[i] = i} for \lstinline{i < size(predecessors)}.
            \end{itemize}
      \pnum\returns 
            \begin{itemize}
                  \item \lstinline{shortest_path_invalid_distance()} returns a sentinel value for an invalid distance,
                        typically \lstinline{numeric_limits<DistanceValue>::max()} for numeric types.
                  \item \lstinline{shortest_path_zero()} returns a value for for a zero-length path,
                        typically \lstinline{0} for numeric types.
            \end{itemize}
\end{itemdescr}


\subsubsection{Dijkstra Single Source Shortest Paths and Shortest Distances}

Compute the shortest path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}
using non-negative weights.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}((|E| + |V|)\log{|V|})$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes \\
\hline
\end{tabular}
%\caption{Dijkstra Single Source Summary}
\label{tab:dijkstra_ss_summary}
\end{table}
Note that complexity may be $\mathcal{O}(|E| + |V|\log{|V|)}$ for certain implementations.

The following functions are split into the common and general cases, where the general cases allow the caller
to specify \tcode{Compare} and \tcode{Combine} functions (e.g. less and add). Concepts and types from 
\tcode{std::ranges} don't include the namespace prefix for brevity and clarity of purpose.

{\small
      \lstinputlisting{D9902/src/dijkstra_common.hpp}
      \lstinputlisting{D9902/src/dijkstra_general.hpp}
}

\begin{itemdescr}
      \pnum\mandates
            \begin{itemize}
                  \item
                        The weight function \lstinline{w} must return a non-negative value.
            \end{itemize}
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{distances} will be initialized with \lstinline{init_shortest_paths}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_invalid_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      %\pnum\throws \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(graph)}.  \\
      %\pnum\complexity \\
      \pnum\remarks 
                        Bellman-Ford Shortest Paths allows negative weights with the consequence of greater complexity. \\
      %\pnum\errors
\end{itemdescr}


\subsubsection{Bellman-Ford Single Source Shortest Paths and Shortest Distances}
Compute the shortest path and associated distance from vertex \tcode{source} to all reachable vertices in \tcode{graph}.


\begin{table}[h]
      \setcellgapes{3pt}
      \makegapedcells
      \centering
      \begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
      \hline
            \multirowcell{2}{
                  \textbf{Complexity} \\
                        $\mathcal{O}(|E| \cdot |V|)$ \\
                  }
            & \textbf{Throws?} No & \textbf{Cycles?} No \\
            & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
      \hline
      \end{tabular}
      %\caption{Bellman-Ford Single Source Summary}
      \label{tab:bellford_ss_summary}
\end{table}
%\andrew{Complexity is really is atrocious.  Suitable only for really small graphs.}


The following functions are split into the common and general cases, where the general cases allow the caller
to specify \tcode{Compare} and \tcode{Combine} functions (e.g. less and add). Concepts and types from 
\tcode{std::ranges} don't include the namespace prefix for brevity and clarity of purpose.

{\small
      \lstinputlisting{D9902/src/bellman_ford_common.hpp}
      \lstinputlisting{D9902/src/bellman_ford_general.hpp}
}

\phil{Should negative weight cycles be a pre-condition, or should it be detected with an exception thrown when it exists?}

\phil{NetworkX has \tcode{negative_edge_cycle} and \tcode{find_negative_cycle}. These are needed if negative weight cycles are a pre-condition?}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{distance} will be initialized with \lstinline{init_shortest_paths}.
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_shortest_paths}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable from vertex \lstinline{source}, then
                        \lstinline{distances[i]} will contain the distance from \lstinline{source} to vertex
                        \lstinline{i}.  Otherwise \lstinline{distances[i]} will contain
                        \lstinline{shortest_path_invalid_distance()}.
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      %\pnum\throws \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(graph)}.  \\
      %\pnum\complexity \\
      \pnum\remarks 
            \begin{itemize}
                  \item
                        Unlike Dijkstra's algorithm, Bellman-Ford allows negative edge weights. Performance constraints limit this to smaller graphs.
            \end{itemize}
      %\pnum\errors
\end{itemdescr}


\section{Clustering}
\subsection{Triangle Counting}
Compute the number of triangles in a graph.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(N^3)$ \\
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Triangle Counting Summary}
\label{tab:triangle_counting_summary}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=6]{D9902/src/tc.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      %\pnum\effects
      %\pnum\result
      \pnum\returns Number of triangles \\
      %\pnum\throws
      %\pnum\complexity \\
      \pnum\remarks
      To avoid duplicate counting, only directed triangles of a certain orientation will be detected. If \tcode{vertex_id(u) < vertex_id(v) < vertex_id(w)}, count triangle if graph contains edges \tcode{uv, vw, uw}.
      %\pnum\errors
\end{itemdescr}


\section{Communities}
\subsection{Label Propagation}
Propagate vertex labels by setting each vertex's label to the most popular label of its neighboring vertices. Every vertex voting on its new label represents one iteration of label propagation. Vertex voting order is randomized every iteration. The algorithm will iterate until label convergence, or optionally for a user specified number of iterations. Convergence occurs when no vertex label changes from the previous iteration. $\mathcal{O}(M)$ complexity is based on the complexity of one iteration, with number of iterations required for convergence considered small relative to graph size.

Some label propagation implementations use vertex ids as an initial labeling. This is not supported here because the label type can be more generic than the vertex id type. User is responsible for meaningful initial labeling.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(M)$ \\
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Label Propagation 1 Summary}
\label{tab:label_prop_1}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=11]{D9902/src/lp.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{label} contains initial vertex labels.
                  \item
                  \lstinline{rng} is a random number generator for vertex voting order.
                  \item
                  \lstinline{max_iters} is the maximum number of iterations of the label propagation, or equivalently the maximum distance a label will propagate from its starting vertex.
            \end{itemize}
      \pnum\effects \lstinline{label[uid]} is the label assignments of vertex id \lstinline{uid} discovered by label propagation.
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity
      \pnum\remarks
      User is responsible for initial vertex labels.
      %\pnum\errors
\end{itemdescr}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(M)$ \\
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Label Propagation 2 Summary}
\label{tab:label_prop_2}
\end{table}

{\small
      \lstinputlisting[firstline=13,lastline=21]{D9902/src/lp.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{label} contains initial vertex labels.
                  \item
                  \lstinline{empty_label} defines a label that is considered empty and will not be propagated.
                  \item
                  \lstinline{rng} is a random number generator for vertex voting order.
                  \item
                  \lstinline{max_iters} is the maximum number of iterations of the label propagation, or equivalently the maximum distance a label will propagate from its starting vertex.
            \end{itemize}
      \pnum\effects \lstinline{label[uid]} is the label assignments of vertex id \lstinline{uid} discovered by label propagation.
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity
      \pnum\remarks
      User is responsible for initial vertex labels.
      %\pnum\errors
\end{itemdescr}

\section{Components}
\subsection{Articulation Points}
Find articulation points, or cut vertices, which when removed disconnect the graph into multiple components. Time complexity based on Hopcroft-Tarjan algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Articulation Points Summary}
\label{tab:articulation_pt_summary}
\end{table}

{\small
     \lstinputlisting[firstline=4,lastline=6]{D9902/src/connected_components.hpp}
}

\phil{Should target of output iterator be convertible to vertex\_id, not same\_as vertex\_id?}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  Output iterator \lstinline{cut_vertices} can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                  Output iterator \lstinline{cut_vertices} contains articulation point vertices, those which removed increase the number of components of \lstinline{g}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{BiConnected Components}
Find the biconnected components, or maximal biconnected subgraphs of a graph, which are components that will remain connected if a vertex is removed. Time complexity based on Hopcroft-Tarjan algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{BiConnected Components}
\label{tab:bi_conn_comp}
\end{table}

{\small
     \lstinputlisting[firstline=11,lastline=16]{D9902/src/connected_components.hpp}
}

\phil{\tcode{push_back}, \tcode{push_front} and \tcode{insert} are all valid ways to add to containers that support forward\_range,
      depending on the specific container type. Are all supported?}

\phil{I think \tcode{convertible_to<...,vertex_id<G>>} would be better than \tcode{integral<...>} because it will catch truncation when 
      assigning vertex\_id to smaller ints in the inner container.}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{components} is a container of containers. The inner container stores vertex ids.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                  \lstinline{components} contains groups of biconnected components.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Connected Components}
Find weakly connected components of a graph. Weakly connected components are subgraphs where a path exists between all pairs of vertices when ignoring edge direction.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} No\\
\hline
\end{tabular}
%\caption{Connected Components Summary}
\label{tab:conn_components}
\end{table}

{\small
     \lstinputlisting[firstline=21,lastline=24]{D9902/src/connected_components.hpp}
}

\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the connected component id of vertex \lstinline{v}.
                  \item
                        There is at least one Connected Component, with compondent id of \lstinline{0}, for \lstinline{num_vertices(g) > 0}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Strongly Connected Components}
\subsubsection{Kosaraju's SCC}
Find strongly connected components of a graph using Kosaraju's algorithm. Strongly connected components are subgraphs where a path exists between all pairs of vertices.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Kosaraju's SCC Summary}
\label{tab:kosaraju_scc}
\end{table}

{\small
      \lstinputlisting[firstline=29, lastline=34]{D9902/src/connected_components.hpp}
}
\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{g_t} is the transpose of \lstinline{g}. Edge \lstinline{uv} in \lstinline{g} implies edge \lstinline{vu} in \lstinline{g_t}. \lstinline{num_vertices(g)} equals \lstinline{num_vertices(g_t)}.
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the strongly connected component id of vertex \lstinline{v}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsubsection{Tarjan's SCC}
Find strongly connected components of a graph using Tarjan's algorithm. Strongly connected components are subgraphs where a path exists between all pairs of vertices.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|+|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Tarjan's SCC Summary}
\label{tab:tarjan_scc_summary}
\end{table}

{\small
      \lstinputlisting[firstline=39,lastline=43]{D9902/src/connected_components.hpp}
}

\phil{Return number of components \tcode{C}? If \tcode{C==num_vertices(g)} then all components are of \tcode{size==1} (a.k.a. no components).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{size(component) >= num_vertices(g)}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{component[v]} is the strongly connected component id of \lstinline{v}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Directed Acyclic Graphs}
\subsection{Topological Sort, Single Source}
A linear ordering of vertices such that for every directed edge (u,v) from vertex u to vertex v, u comes before v in the ordering.

\subsubsection{Initialization}

{\small
      \lstinputlisting{D9902/src/topological_sort_helpers.hpp}
}

\begin{itemdescr}
      \effects
      \begin{itemize}
            \item
                  Each \lstinline{predecessors[i]} is initialized to \lstinline{i}.
      \end{itemize}
\end{itemdescr}

\subsubsection{Topological Sort, Single Source}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
                  $\mathcal{O}((|E| + |V|))$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes \\
\hline
\end{tabular}
%\caption{Topological Sort Single Source Summary}
\label{tab:toposort_ss_summary}
\end{table}

{\small
      \lstinputlisting{D9902/src/topological_sort.hpp}
}

\phil{Add overload with \tcode{distances}}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= source < num_vertices(graph)}. 
                  \item
                        \lstinline{predecessors} will be initialized with \lstinline{init_topological_sort}.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        If vertex with index \lstinline{i} is reachable
                        from vertex \lstinline{source}, then \lstinline{predecessors[i]} will contain the
                        predecessor vertex of vertex \lstinline{i}. Otherwise \lstinline{predecessors[i]} will contain
                        \lstinline{i}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns \lstinline{void} \\
      %\pnum\throws \tcode{out_of_range} is thrown when \tcode{source} is not in the range \tcode{0 <= source < num_vertices(graph)}.  \\
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}





\section{Maximal Independent Set}
\subsection{Maximal Independent Set}
Find a maximally independent set of vertices in a graph starting from a seed vertex. An independent vertex set indicates no pair of vertices in the set are adjacent.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} No\\
\hline
\end{tabular}
%\caption{Maximal Independent Set Summary}
\label{tab:mis_summary}
\end{table}

{\small
      \lstinputlisting{D9902/src/mis.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= seed < num_vertices(graph)}.
                  \item
                        \lstinline{mis} output iterator can be assigned vertices of type \lstinline{vertex_id_t<G>} when dereferenced.
      \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        Output iterator \lstinline{mis} contains maximal independent set of vertices containing \lstinline{seed}, 
                        which is a subset of \lstinline{vertices(graph)}. \\
      \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Link Analysis}

% pagerank removed because there are many variations and corner cases to cover
% It fits better in an example. 08-Nov-2023

\subsection{Jaccard Coefficient}
Calculate the Jaccard coefficient of a graph

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|N|^3)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Jaccard Coefficient Summary}
\label{tab:jaccard_summary}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=6]{D9902/src/jaccard.hpp}
}

\phil{Consider using \tcode{out(uid,vid,uv,val)} as the function descriptor in Preconditions to make it more readable.}

\phil{Would an output iterator be appropriate? \tcode{pair<edge_id_t<G>>,T>} might work for the output type. This starts to get into the same realm of the views
as to whether the edge reference is useful by the consumer or not (e.g. basic\_ vs. regular versions).}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                  \lstinline{out} is an operator for setting the resulting Jaccard coefficient. This function is expected to be of the form \lstinline{out(vertex_id_t<G> uid, vertex_id_t<G> vid, edge_t<G> uv, T val)}.
            \end{itemize}
      \pnum\effects 
            \begin{itemize}
                  \item
                        For every pair of neighboring vertices \lstinline{(uid, vid)}, the function \lstinline{out} is called, passing the vertex ids, 
                        the edge \lstinline{uv} between them, and the calculated Jaccard coefficient.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\section{Minimum Spanning Tree}
%\andrew{Simplified ``driver'' for these also?}

\subsection{Kruskal Minimum Spanning Tree}
Find the minimum weight spanning tree of a graph using Kruskal's algorithm.

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} Yes\\
\hline
\end{tabular}
%\caption{Kruskal Minimum Spanning Tree Summary}
\label{tab:kruskal_mst_summary}
\end{table}

{\small
      \lstinputlisting[firstline=4,lastline=8]{D9902/src/mst.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{e} is an \lstinline{edgelist}.
                  \item
                        \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{edge_value_t<EL>} 
                        which returns a bool.
            \end{itemize}
      \pnum\effects 
            \begin{itemize}
                  \item
                        Edgelist \lstinline{t} contains edges representing a spanning tree or forest, which minimize the comparison operator. 
                        When \lstinline{compare} is \lstinline{<}, \lstinline{t} represents a minimum weight spanning tree.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\subsection{Prim Minimum Spanning Tree}
Find the minimum weight spanning tree of a graph using Prim's algorithm.

\phil{Use general form of dijkstra's shortest path?}

\begin{table}[h]
\setcellgapes{3pt}
\makegapedcells
\centering
\begin{tabular}{|P{0.30\textwidth}|P{0.25\textwidth}|P{0.25\textwidth}|}
\hline
      \multirowcell{2}{
            \textbf{Complexity} \\
            $\mathcal{O}(|E|log|V|)$
            }
      & \textbf{Throws?} No & \textbf{Cycles?} No \\
      & \textbf{Multi-edge?} No & \textbf{Directed?} No \\
\hline
\end{tabular}
%\caption{Prim Minimum Spanning Tree Summary}
\label{tab:prim_mst_summary}
\end{table}

{\small
      \lstinputlisting[firstline=13,lastline=29]{D9902/src/mst.hpp}
}
\begin{itemdescr}
      %\pnum\mandates
      %\pnum\preconditions
      %\pnum\effects
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\begin{itemdescr}
      %\pnum\mandates
      \pnum\preconditions
            \begin{itemize}
                  \item
                        \lstinline{0 <= seed < num_vertices(g)}.
                  \item
                        Size of \lstinline{weight} and \lstinline{predecessor} is greater than or equal to \lstinline{num_vertices(g)}.
                  \item
                        \lstinline{compare} operator is a valid comparison operation on two edge values of type \lstinline{edge_value_t<G>} which returns a bool.
            \end{itemize}
      \pnum\effects
            \begin{itemize}
                  \item
                        \lstinline{predecessor[v]} is the parent vertex of \lstinline{v} in a tree rooted at \lstinline{seed} and \lstinline{weight[v]} is the value of the edge between \lstinline{v} and \lstinline{predecessor[v]} in the tree. When \lstinline{compare} is \lstinline{<} and \lstinline{init_dist==+inf}, \lstinline{predecessor} represents a minimum weight spanning tree.
                  \item
                        If \lstinline{predecessor} and \lstinline{weight} are not initialized by user, and the graph is not fully connected, \lstinline{predecessor[v]} and \lstinline{weight[v]} will be undefined for vertices not in the same connected component as \lstinline{seed}.
            \end{itemize}
      %\pnum\result
      %\pnum\returns
      %\pnum\throws
      %\pnum\complexity \\
      %\pnum\remarks 
      %\pnum\errors
\end{itemdescr}

\andrew{I've tagged the algorithms below as Tier 2 or Tier 3 -- denoting whether they should be done right now or done later or done much later.}

\andrew{I've used NetworkX as inspiration for organization.  Oddly, NetworkX only has DFS as an adaptor (view).}
\phil{If the use of Yield is any indicator, then NetworkX implements topological sort as adaptor also.}




\begin{comment}

      %Algorithms with [TBD] are candidates to consider but having been decided for being in the paper
      %We are targeting the paper to be under 50pp
      All algorithms are customization points.

      \phil{Algorithms marked [TBD] are provisional and may be moved to a separate proposal to keep the size of this proposal manageable}

      \subsection{Dijkstra's Shortest Paths and Shortest Distances}
      Dijkstra's algorithm \cite{REF_} is a single-source, shortest paths algorithm for non-negative weights. It finds the shortest paths
      and their weighted distances to all vertices connected to a single seed vertex.

      \begin{lstlisting}
      template <adjacency_list G, class DistanceValue>
      auto dijkstra_invalid_distance() {
      return numeric_limits<DistanceValue>::max();
      }

      template <adjacency_list              G,
            ranges::random_access_range Distance,
            ranges::random_access_range Predecessor,
            class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
            queueable Q = 
                  priority_queue<
                        weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                        vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                        greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
      requires ranges::random_access_range<vertex_range_t<G>> &&                  //
            integral<vertex_id_t<G>> &&                                           //
            is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
            convertible_to<vertex_id_t<G>, ranges::range_value_t<Predecessor>> && //
            edge_weight_function<G, EVF>
      constexpr void dijkstra_shortest_paths(
            G&&            g,           // graph
            vertex_id_t<G> seed,        // starting vertex_id
            Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
            Predecessor&   predecessor, // out: predecessor[uid] of vertex_id uid in path
            EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                          { return ranges::range_value_t<Distance>(1); },
            Q              q = Q()
            );
      \end{lstlisting}

      \begin{table}[h!]
            %\begin{center}
            %\resizebox{\textwidth}{!}
            {\begin{tabular}{l l}
                        \hline
                        \textit{Complexity}     & O(V log(V)).                                                                                                                                                  \\
                                                & Additional time will be required to pre-extend  or initialize the \tcode{distance} range by the caller.                                                       \\
                                                & Additional time may also be required to pre-extend \tcode{predecessor}.                                                                                       \\
                        \andrew{O((|E| + |V|)log(|V|) or O(|E| + |V|log(|V|).  Initializing distance and predecessor are O(|V|) so don't change the complexity.}
                        \hline
                        \textit{Constraints}    & Values returned by \tcode{weight_fn} must be non-negative.                                                                                                    \\
                        \hline
                        \textit{Preconditions}  & \tcode{seed >= 0                                                                                                               &  & seed < size(vertices(g))} \\
                                                & \tcode{size(distance) >= size(vertices(g))}; caller must pre-extend with \tcode{dijkstra_invalid_distance()}                                                   \\
                                                & \tcode{size(predecessor) >= size(vertices(g))}; caller must pre-extend                                                                                        \\
                                                & \tcode{distance[i] = dijkstra_invalid_distance()} for \tcode{i < size(vertices(g))}                                                                           \\
                        \hline
                        \textit{Postconditions} & \tcode{distance[seed] == 0}                                                                                                                                   \\
                                                & \tcode{predecessor[seed] == seed}.                                                                                                                            \\
                        \hline
                        \textit{\effects}       & \tcode{distance[uid]} will be the shortest, weighted distance of vertex\_id \tcode{uid} from \tcode{seed}.                                                    \\
                                                & If \tcode{uid} is not connected to \tcode{seed} by any edges then it will have a value of \tcode{dijkstra_invalid_distance()}.                                \\
                                                &                                                                                                                                                               \\
                                                & \tcode{predecessor[uid]} will have the preceding vertex\_id of \tcode{uid} in the weighted shortest path to \tcode{seed}                                      \\
                                                & when \tcode{distance[uid] != dijkstra_invalid_distance()}.                                                                                                    \\
                        \hline
                  \end{tabular}}
            %\caption{\tcode{incidence} View Functions}
            %\label{tab:incidence}
            %\end{center}
      \end{table}

      \phil{Describe the pros and cons of different kinds of queues}

      The default weight function \tcode{weight_fn} returns a value of 1. When that is used, \tcode{distance[uid]} will have the shortest number of edges
      between vertex \tcode{uid} and vertex \tcode{seed}. The distance from \tcode{seed} to itself is zero.

      If the caller wishes to use a different queue other than \tcode{priority_queue}, the queue will need to have elements of \tcode{weighted_vertex}
      which is used internally by the algorithm.
      \begin{lstlisting}
      template <class G, class W>
      requires is_default_constructible_v<vertex_id_t<G>> && is_default_constructible_v<W>
      struct weighted_vertex {
      vertex_id_t<G> vertex_id = vertex_id_t<G>();
      W              weight    = W();
      constexpr auto operator<=>(const weighted_vertex&) const noexcept; // compare vertex_id
      };
      \end{lstlisting}

      The \tcode{dijkstra_shortest_distances} function is the same as \tcode{dijkstra_shortest_paths} except that it doesn't include
      the \tcode{predecessor} parameter.
      \begin{lstlisting}
      template <adjacency_list              G,
            ranges::random_access_range Distance,
            class EVF   = std::function<ranges::range_value_t<Distance>(edge_reference_t<G>)>,
            queueable Q = 
                  priority_queue<
                        weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>,
                        vector<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>,
                        greater<weighted_vertex<G,invoke_result_t<EVF,edge_reference_t<G>>>>>>
      requires ranges::random_access_range<vertex_range_t<G>> &&                  //
            integral<vertex_id_t<G>> &&                                           //
            is_arithmetic_v<ranges::range_value_t<Distance>> &&                   //
            edge_weight_function<G, EVF>
      constexpr void dijkstra_shortest_distances(
            G&&            g,           // graph
            vertex_id_t<G> seed,        // starting vertex_id
            Distance&      distance,    // out: distance[uid] of vertex_id uid from seed
            EVF            weight_fn = [](edge_reference_t<G> uv)  // weight_fn(uv) -> 1
                                          { return ranges::range_value_t<Distance>(1); },
            Q              q = Q()
            );
      \end{lstlisting}

      \subsection{[TBD] Delta Stepping Shortest Paths}
      The  algorithm \cite{REF_} ...

      \subsection{Bellman-Ford Shortest Paths}
      The Bellman-Ford algorithm \cite{REF_} ...

      \subsection{[TBD] Shortest Paths}
      (Overloads to select appropriate algorithm based on inputs)

      \subsection{Connected Components}
      Connected components \cite{REF_} ...

      \subsection{Strongly Connected Components}
      Strongly connected components \cite{REF_} ...

      \subsection{Biconnected Components}
      Biconnected components \cite{REF_} ...

      \subsection{Articulation Points}
      Articulation points \cite{REF_} ...

      \subsection{Minimum Spanning Tree}
      Minimum Spanning Tree \cite{REF_} ...

      \subsection{[TBD] Betweenness Centrality}
      \subsection{[TBD] Triangle Count}
      \subsection{[TBD] Subgraph Isomorphism}
      \subsection{[TBD] Kruskal Minimum Spanning Tree}
      \subsection{[TBD] Prim Minimum Spanning Tree}
      \subsection{[TBD] Louvain (Community Detection)}
      \subsection{[TBD] Label propagation (Community Detection)}

\end{comment}
