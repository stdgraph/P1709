
\chapter{Overview}

Graphs, used in ML and other \textbf{scientific} domains, as well as \textbf{industrial} and \textbf{general} programming, 
do \textbf{not} presently exist in the C++ standard. In ML, a graph forms the underlying structure of an \textbf{artificial neural network} (ANN). 
In a \textbf{game}, a graph can be used to represent the \textbf{map} of a game world. In \textbf{business} environments, graphs arise as 
\textbf{entity relationship diagrams} (ERD) or \textbf{data flow diagrams} (DFD). In the realm of \textbf{social media}, a graph represents a 
\textbf{social network}.

This document proposes the addition of \textbf{graph algorithms}, \textbf{graph views}, \textbf{graph container interface} and a 
\textbf{graph container implementation} to the C++ library to support \textbf{machine learning} (ML), as well as other applications. 
ML is a large and growing field, both in the \textbf{research community} and \textbf{industry}, that has received a great deal of 
attention in recent years. This paper presents an \textbf{interface} of the proposed algorithms, views, graph functions and containers.

\section{Goals and Priorities}
\begin{itemize}
\item Follow the separation of algorithms, ranges, views and containers established by the standard library.
\item Graph algorithms have the following characteristics
\begin{itemize}
\item Support syntax that is simple, expressive and easy to understand. This should not compromise the ability to write high-performance algorithms.
\item Vertices are required to be in random access containers with an integral vertex\_id in this proposal.
\end{itemize}
\item Graph views provide common traversals of a graph's vertices and edges that is more concise and consistant than using the graph container interface directly. They include simple traversals like vertexlist (all vertices in the graph) and incidence edges (edges on a vertex), as well as more complex traversals like depth-first and breath-first searches.
\item All free functions are customization point objects in the Graph Container Interface and Views, unless noted otherwise. Reasonable default implementations are provided whenever possible.
\item The Graph Container Interface provides a consistent interface that can be used by algorithms and views. It has the following characteristics:
\begin{itemize}
\item The interface models an adjacency graph container, which is an outer range of vertices with an inner range of outgoing (a.k.a. incidence) edges on each vertex. 
\item Definition of concepts, types, type traits, type aliases, and functions used by algorithms and views.
\begin{itemize}
\item Type traits will be defined that can be overridden for each graph container to give additional hints that can be used by algorithms to refine their behavior, such as adjacency\_matrix and unordered\_edge.
\end{itemize}
\item Support of optional user-defined value types on an edge, vertex and/or the graph itself.
\item Support bipartite and multipartite graphs, as long as the underlying graph supports it. If the underlying graph doesn't support either,
      it is considered unipartite with a single partition.
\item Allow for useful extensions of the graph data model in future proposals or in external graph implementations. 
\end{itemize}
\item Define an Edge List interface, required by some algorithms, that can be used by user-defined ranges for algorithms that require them.
\item Provide an initial suite of useful functionality that includes algorithms, views, container interface, and at least one 
model container implementation.
\end{itemize}

\section{Examples}

%\andrew{Where do examples really belong?  In P2300 they are up front here, but I think there is too much forward referencing for that.}

The following code demonstrates how a simple graph can be created as a range of ranges, using the standard containers. 

\phil{Duplicated in Introduction. OK?}

\phil{Validate that code works}

{\small
  \lstinputlisting[firstline=26,lastline=48]{D9901/src/bacon.cpp}
}

\tcode{target_id(g,uv)} defines the required function to get a target\_id for an edge in the graph \tcode{G}. Other functions can also
be overridden to allow a developer to adapt their own graph data structures to the library.

\section{What this proposal is  \textbf{not}}

This paper limits itself to adjacency graphs and edgelists only. An adjacency graph is an outer range of vertices with an inner range of outgoing
edges on each vertex. An edgelist is a view of edges, which is either all the edges in the adjacency graph or a projection of a user-defined range.

Parallel versions of the algorithms are not included for several reasons. The executors proposal in P2300r5 \cite{REF_P2300r5} is expected to introduce new 
and better ways to do parallel algorithms beyond that used in the parallel STL algorithms and we would like to wait for finalization of that proposal before 
committing to parallel implementations. Secondly, many graph algorithms don't benefit from parallel implementations so there is less need to offer an implementation. 
Lastly, it will help limit the size of this proposal which is already looking to be large without it. It is expected that future proposals will be submitted for parallel graph algorithms. 

Incoming edges on a vertex are not included, though it is hoped that a future proposal will be made for them.

The algorithms and views in this proposal expect that vertex\_ids are densly assigned in a random access range, but it does not exclude the possibility of 
sparsely-defined vertex\_ids stored in containers like \lstinline{std::map} or \tcode{std::unordered_map} in future proposals. 

The algorithms and views in this proposal expect that vertex\_ids are integal, but it does not exclude non-integral or user-defined types in future proposals.

Hypergraphs are not supported.

\section{Impact on the Standard}
This proposal is a pure \textbf{library} extension.

\section{Interaction wtih Other Papers}
There is no interaction with other proposals to the standard.

\section{Implementation Experience}
The github \href{https://github.com/stdgraph}{github.com/stdgraph} repository contains an implementation for this proposal.

\section{Usage Experience}
There is no current use of the library. There are plans to begin using it in 2024 in a commercial setting.

\section{Deployment Experience}
There is no current deployment experience of the library. There are plans for this to follow the usage experience.

\section{Performance Considerations}
The algorithms are being ported from NWGraph to the \href{https://github.com/stdgraph}{github.com/stdgraph} implementation used for this proposal. Performance analysis from those algorithms can be found in the peer-reviewed papers for NWGraph~\cite{REF_nwgraph_paper,gapbs_2023}.

\section{Prior Art}
\textbf{boost::graph} has been an important C++ graph implementation since 2001. It was developed with the goal of providing
a modern (at the time) generic library that addressed all the needs someone would want of a graph library. It is still a viable library used today, attesting to the value it brings.

However, boost::graph was written using C++98 in an ``expert-friendly'' style, adding many abstractions and using sophisticated tempate metaprogramming, making it difficult to use by a casual developer.

(Andrew is a co-author of boost::graph.)

\medskip

\textbf{NWGraph} (\cite{REF_nwgraph_library} and \cite{REF_nwgraph_paper}) was published in 2022
by Lumsdaine et al, bringing additional experience gained since creating boost::graph, to create a modern graph library using C++20 for its implementation 
that was more accessible to the average developer. % with the latest algorithms.

While NWGraph made important strides to introduce the idea of the graph as a range-of-ranges and implemented many important algorithms,
there are some areas it didn't address that come a practical use in the field. For instance, it didn't have a well-defined API for graph
data structures that could be applied to existing graphs, and there wasn't a uniform approach to properties.

This proposal takes the best of NWGraph, with previous work done for P1709 to define a Graph Container Interface, to provide a library that
embraces performance, ease-of-use and the ability to use the algorithms and views on externally defined graph containers.

\section{Alternatives}
We're unaware of any other library that meets the same requirements and uses concepts and ranges from C++20.

%Later revisions should include this:
%\section{Changes Library Evolution previously requested}

\section{Feature Test Macro}
The \tcode{__cpp_lib_graph} feature test macro is recommended to represent all features in this proposal including algorithms, views, concepts, traits, types, functions and graph container(s).

\section{Freestanding}
We believe this library can be used in a freestanding C++ implementation.

\section{Namespaces}
Graph containers and their views and algorithms are not interchangeable with existing containers and algorithms.
Additionally, there are some domain-specific terms that may clash with existing or future names, such as 
\tcode{degree} and \tcode{partition_id}.
For these reasons, we recommend their own namespaces. The following assumption is used in this proposal.
\begin{itemize}
\item[]\tcode{std::graph} and \tcode{std::graph::views}
\end{itemize}

\noindent
Alternative locations include the following:
\begin{itemize}
\item[]\tcode{std::ranges} and \tcode{std::ranges::views}
\item[]\tcode{std::ranges/graph} and \tcode{std::ranges::graph::views}
\end{itemize}
The advantage of these two options are that there would be no requirement to use the ranges:: prefix for things
in the std::ranges namespace, a common occurance.
