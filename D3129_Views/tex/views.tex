%f% \chapter{Views}

\clearpage

\section{Introduction}

\phil{Use \tcode{basic_index_adjacency_list} as the concept for all views.}

\phil{Group views by basic first, like with concepts.}

\phil{Use \tcode{&&} instead of \tcode{const\&} for value function parameters.}

\phil{Can \tcode{std::ref} be used for the value function?}


% Phil:
% It's tempting to try to consolidate the views so there's no regular views that return a reference to a vertex/edge,
% versus the basic_ views that don't include the reference. There doesn't appear to be any real need to include the
% reference since the vvf/evf can be used to return the value(s) needed by the algorithm.
%
% That's true for the cases where the vertex_id/target_id is also returned by the view. However, for other types
% of graph data structures, it may be better to have the vertex/edge reference for edges(g,u) or target_id(g,uv)
% because there is likely a way to get the return value in O(1) time instead of O(log n) when using an id.
%

The views in this paper provide common ways that algorithms use to traverse graphs. They are a simple as iterating 
through the set of vertices, or more complex ways such as depth-first search and breadth-first search. The also 
provide a consistent and reliable way to access related elements using the View Return Types, and guaranteeing expected 
values, such as that the target is really the target on unordered edges.

\section{Descriptors (Return Types)}
Views return one of the types in this section, providing a consistent set of value types for all graph data structures. 
They are templated so that the view can adjust the actual values returned to be appropriate for its use. The three types, 
\tcode{vertex_descriptor, edge_descriptor} and \tcode{neighbor_descriptor}, define the common data model used by algorithms.

The following examples show the general design and how it's used. While it focuses 
on vertexlist to iterate over all vertices, it applies to all descriptors and view functions.

\begin{lstlisting}
// the type of uu is vertex\_descriptor<vertex\_id\_t<G>, vertex\_reference\_t<G>, void>
for(auto&& uu : vertexlist(g)) {
  vertex_id<G>          id = uu.id;
  vertex_reference_t<G> u  = uu.vertex;
  // ... do something interesting
}
\end{lstlisting}

Structured bindings make it simpler.
\begin{lstlisting}
for(auto&& [id, u] : vertexlist(g)) {
  // ... do something interesting
}
\end{lstlisting}

A function object can also be passed to return a value from the vertex. In this case, \tcode{vertexlist(g)} returns \tcode{vertex_descriptor<vertex_id_t<G>, vertex_reference_t<G>, decltype(vvf(u))>}.
\begin{lstlisting}
// the type returned by vertexlist is 
// vertex\_descriptor<vertex\_id\_t<G>, 
//                    vertex\_reference\_t<G>, 
//                    decltype(vvf(vertex\_reference\_t<G>))>
auto vvf = [&g](vertex_reference_t<G> u) { return vertex_value(g,u); };
for(auto&& [id, u, value] : vertexlist(g, vvf)) {
  // ... do something interesting
}
\end{lstlisting}

A simpler version also exists if all you need is a vertex id. The vertex value function takes a vertex id
instead of a vertex reference.
\begin{lstlisting}
for(auto&& [uid] : basic_vertexlist(g)) {
  // ... do something interesting
}

auto vvf = [&g](vertex_id_t<G> uid) { return vertex_value(g,uid); };
for(auto&& [uid, value] : basic_vertexlist(g,vvf)) {
  // ... do something interesting
}
\end{lstlisting}

\subsection{\tcode{struct vertex_descriptor<VId, V, VV>}}\label{vertex-view}\mbox{} \\
\tcode{vertex_descriptor} is used to return vertex information. It is used by \tcode{vertexlist(g)}, \tcode{vertices_breadth_first_search(g,u)}, 
\tcode{vertices_dfs(g,u)} and others. The \tcode{id} member always exists.

{\small
     \lstinputlisting{D3129_Views/src/vertex_descriptor.hpp}
}

Specializations are defined with \tcode{V=void} or \tcode{VV=void} to suppress the existance of their associated member variables, 
giving the following valid combinations in Table \ref{tab:vertex-view} . For instance, the second entry, \tcode{vertex_descriptor<VId, V>} 
has two members \tcode{\{id_type id; vertex_type vertex;\}} and \tcode{value_type} is \tcode{void}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{3}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & vertex & value \\
\hline
    \tcode{vertex_descriptor<VId, V, VV>} & \tcode{id} & \tcode{vertex} & \tcode{value} \\
    \tcode{vertex_descriptor<VId, V, void>} & \tcode{id} & \tcode{vertex} & \\
    \tcode{vertex_descriptor<VId, void, VV>} & \tcode{id} & & \tcode{value} \\
    \tcode{vertex_descriptor<VId, void, void>} & \tcode{id} & & \\
\hline
\end{tabular}}
\caption{\tcode{vertex_descriptor} Members}
\label{tab:vertex-view}
\end{center}
\end{table}

\subsection{\tcode{struct edge_descriptor<VId, Sourced, E, EV>}}\label{edge-view}\mbox{} \\
\tcode{edge_descriptor} is used to return edge information. It is used by 
\tcode{incidence(g,u), edgelist(g), edges_breadth_first_search(g,u), edges_dfs(g,u)} and others. 
When \tcode{Sourced=true}, the \tcode{source_id} member is included with type \tcode{VId}. The \tcode{target_id} member always exists.

{\small
     \lstinputlisting{D3129_Views/src/edge_descriptor.hpp}
}

Specializations are defined with \tcode{Sourced=true|false}, \tcode{E=void} or \tcode{EV=void} to suppress the existance of the associated 
member variables, giving the following valid combinations in Table \ref{tab:edge-view} . For instance, the second entry, 
\tcode{edge_descriptor<VId,true,E>} has three members \tcode{\{source_id_type source_id; target_id_type target_id; edge_type edge;\}} 
and \tcode{value_type} is \tcode{void}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
    %\textbf{Template Arguments} & id & edge & value \\
\hline
    \tcode{edge_descriptor<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_descriptor<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_descriptor<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_descriptor<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{edge_descriptor<VId, false, E, EV>} & & \tcode{target_id} & \tcode{edge} & \tcode{value} \\
    \tcode{edge_descriptor<VId, false, E, void>} & & \tcode{target_id} & \tcode{edge} & \\
    \tcode{edge_descriptor<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{edge_descriptor<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{edge_descriptor} Members}
\label{tab:edge-view}
\end{center}
\end{table}

\subsection{\tcode{struct neighbor_descriptor<VId, Sourced, V, VV>}}\label{neighbor-view}\mbox{} \\
\tcode{neighbor_descriptor} is used to return information for a neighbor vertex, through an edge. It is used by \tcode{neighbors(g,u)}. 
When \tcode{Sourced=true}, the \tcode{source_id} member is included with type \tcode{source_id_type}. The \tcode{target_id} member always exists.

{\small
     \lstinputlisting{D3129_Views/src/neighbor_descriptor.hpp}
}

Specializations are defined with \tcode{Sourced=true|false}, \tcode{E}=void or \tcode{EV}=void to suppress the existance of the 
associated member variables, giving the following valid combinations in Table \ref{tab:neighbor-view} . For instance, the second entry, 
\tcode{neighbor_descriptor<VId,true,E>} has three members \tcode{\{source_id_type source_id; target_id_type target_id; vertex_type target;\}} 
and \tcode{value_type} is \tcode{void}.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l |c c c c}
\hline
    \multicolumn{1}{l}{\textbf{Template Arguments}}
    &
    \multicolumn{4}{c}{\textbf{Members}} \\
\hline
    \tcode{neighbor_descriptor<VId, true, E, EV>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_descriptor<VId, true, E, void>} & \tcode{source_id} & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_descriptor<VId, true, void, EV>} & \tcode{source_id} & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_descriptor<VId, true, void, void>} & \tcode{source_id} & \tcode{target_id} & & \\
    \tcode{neighbor_descriptor<VId, false, E, EV>} & & \tcode{target_id} & \tcode{target} & \tcode{value} \\
    \tcode{neighbor_descriptor<VId, false, E, void>} & & \tcode{target_id} & \tcode{target} & \\
    \tcode{neighbor_descriptor<VId, false, void, EV>} & & \tcode{target_id} & & \tcode{value} \\
    \tcode{neighbor_descriptor<VId, false, void, void>} & & \tcode{target_id} & & \\
\hline
\end{tabular}}
\caption{\tcode{neighbor_descriptor} Members}
\label{tab:neighbor-view}
\end{center}
\end{table}

\subsection{Copyable Descriptors}

\subsubsection{Copyable Descriptor Types}
Copyable descriptors are specializations of the descriptors that can be copied. More specifically, they don't include
a vertex or edge reference. \tcode{copyable_vertex_t<G>} shows the simple definition.

\begin{lstlisting}
template <class VId, class VV=void>
using copyable_vertex_t = vertex_descriptor<VId, void, VV>; // {id, value}
\end{lstlisting}

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l L{12.0cm}}
\hline
    \textbf{Type} & \textbf{Definition} \\
\hline
    \tcode{copyable_vertex_t<T,VId,VV=void>} & \tcode{vertex_descriptor<VId, void, VV>} \\
    \tcode{copyable_edge_t<T,Vid,EV=void>} & \tcode{edge_descriptor<VId, true, void, EV>>} \\
    \tcode{copyable_neighbor_t<Vid,VV=void>} & \tcode{neighbor_descriptor<VId, true, void, VV>} \\
\hline
\end{tabular}}
\caption{Descriptor Concepts}
\label{tab:descriptor_concepts}
\end{center}
\end{table}

\subsubsection{Copyable Descriptor Concepts (For Exposition Only)}

Given the copyable types, it's useful to have concepts to determine if a type is a desired copyable type.
\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l L{12.0cm}}
\hline
    \textbf{Concept} & \textbf{Definition} \\
\hline
    \tcode{copyable_vertex<T,VId,VV=void>} & \tcode{convertible_to<T, copyable_vertex_t<VId, VV>>} \\
    \tcode{copyable_edge<T,Vid,EV=void>} & \tcode{convertible_to<T, copyable_edge_t<VId, EV>>} \\
    \tcode{copyable_neighbor<T,Vid,VV=void>} & \tcode{convertible_to<T, copyable_neighbor_t<VId, VV>>} \\
\hline
\end{tabular}}
\caption{Descriptor Concepts}
\label{tab:descriptor_concepts}
\end{center}
\end{table}



\section{Graph Views}

\subsection{vertexlist Views}

\tcode{vertexlist} views iterate over a range of vertices, returning a \tcode{vertex_descriptor} on each iteration. 
Table \ref{tab:vertexlist} shows the vertexlist functions overloads and their return values. \tcode{first} and \tcode{last} are vertex iterators.

\tcode{vertexlist} views require a \tcode{vvf(u)} function, and the \tcode{basic_vertexlist} views require a \tcode{vvf(uid)} function.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,u] : vertexlist(g))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vvf))} & \tcode{vertex_descriptor<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,first,last))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,first,last,vvf))} & \tcode{vertex_descriptor<VId,V,VV>} \\
    \tcode{for(auto\&\& [uid,u] : vertexlist(g,vr))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [uid,u,val] : vertexlist(g,vr,vvf))} & \tcode{vertex_descriptor<VId,V,VV>} \\
\hdashline
    \tcode{for(auto\&\& [uid] : basic_vertexlist(g))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [uid,val] : basic_vertexlist(g,vvf))} & \tcode{vertex_descriptor<VId,void,VV>} \\
    \tcode{for(auto\&\& [uid] : basic_vertexlist(g,first,last))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [uid,val] : basic_vertexlist(g,first,last,vvf))} & \tcode{vertex_descriptor<VId,void,VV>} \\
    \tcode{for(auto\&\& [uid] : basic_vertexlist(g,vr))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [uid,val] : basic_vertexlist(g,vr,vvf))} & \tcode{vertex_descriptor<VId,void,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{vertexlist} View Functions}
\label{tab:vertexlist}
\end{center}
\end{table}

\subsection{incidence Views}
\tcode{incidence} views iterate over a range of adjacent edges of a vertex, returning a \tcode{edge_descriptor} on each iteration. 
Table \ref{tab:incidence} shows the \tcode{incidence} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling an \tcode{incidence} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\tcode{incidence} views require a \tcode{evf(uv)} function, and  \tcode{basic_incidence} views require a \tcode{evf(eid)} function.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,uv] : incidence(g,uid))} & \tcode{edge_descriptor<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : incidence(g,uid,evf))} & \tcode{edge_descriptor<VId,false,E,EV>} \\
\hdashline
    \tcode{for(auto\&\& [vid] : basic_incidence(g,uid))} & \tcode{edge_descriptor<VId,false,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_incidence(g,uid,evf))} & \tcode{edge_descriptor<VId,false,void,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{incidence} View Functions}
\label{tab:incidence}
\end{center}
\end{table}

\subsection{neighbors Views}
\tcode{neighbors} views iterate over a range of edges for a vertex, returning a \tcode{vertex_descriptor} of each neighboring target vertex on each iteration. 
Table \ref{tab:neighbors} shows the \tcode{neighbors} function overloads and their return values. 

Since the source vertex \tcode{u} is available when calling a \tcode{neighbors} function, there's no need to include sourced versions of the function to include \tcode{source_id} in the output.

\tcode{neighbors} views require a \tcode{vvf(u)} function, and the \tcode{basic_neighbors} views require a \tcode{vvf(uid)} function.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : neighbors(g,uid))} & \tcode{neighbor_descriptor<VId,false,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : neighbors(g,uid,vvf))} & \tcode{neighbor_descriptor<VId,false,V,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid] : basic_neighbors(g,uid))} & \tcode{neighbor_descriptor<VId,false,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_neighbors(g,uid,vvf))} & \tcode{neighbor_descriptor<VId,false,void,VV>} \\
\hline
\end{tabular}}
\caption{\tcode{neighbors} View Functions}
\label{tab:neighbors}
\end{center}
\end{table}

\subsection{edgelist Views}
\tcode{edgelist} views iterate over all edges for all vertices, returning a \tcode{edge_descriptor} on each iteration. 
Table \ref{tab:edgelist} shows the \tcode{edgelist} function overloads and their return values. 

\tcode{edgelist} views require a \tcode{evf(uv)} function, and  \tcode{basic_edgelist} views require a \tcode{evf(eid)} function.

The range returned by \tcode{edgelist} adheres to the  \tcode{basic_sourced_index_edgelist} concept (future proposals may only
adhere to \tcode{basic_sourced_edgelist}). If a \tcode{evf(uv)} function is passed, it adheres to the \tcode{has_edge_value} concept.

\begin{table}[h!]
\begin{center}
%\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [uid,vid,uv] : edgelist(g))} & \tcode{edge_descriptor<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : edgelist(g,evf))} & \tcode{edge_descriptor<VId,true,E,EV>} \\
\hdashline
    \tcode{for(auto\&\& [uid,uv] : basic_edgelist(g))} & \tcode{edge_descriptor<VId,true,void,void>} \\
    \tcode{for(auto\&\& [uid,uv,val] : basic_edgelist(g,evf))} & \tcode{edge_descriptor<VId,true,void,EV>} \\
\hline
\end{tabular}}
\caption{\tcode{edgelist} View Functions}
\label{tab:edgelist}
\end{center}
\end{table}

\section{"Search" Views}

\subsection{Common Types and Functions for ``Search'' }
\phil{Do these apply to all "search" functions?}

The Depth First, Breadth First, and Topological Sort searches share a number of common types and functions. 

Here are the types and functions for cancelling a search, getting the current depth of the search, and active elements in the search (e.g. number of vertices in a stack or queue).
\begin{lstlisting}
// enum used to define how to cancel a search
enum struct cancel_search : int8_t { 
  continue_search, // no change (ignored)
  cancel_branch,   // stops searching from current vertex
  cancel_all       // stops searching and dfs will be at end()
};

// stop searching from current vertex
template<class S)
void cancel(S search, cancel_search);

// Returns distance from the seed vertex to the current vertex, 
// or to the target vertex for edge views
template<class S>
auto depth(S search) -> integral;

// Returns number of pending vertices to process
template<class S>
auto size(S search) -> integral; 
\end{lstlisting}

Of particular note, \tcode{size(dfs)} is typically the same as \tcode{depth(dfs)} and is simple to calculate. breadth\_first\_search requires extra bookkeeping to evaluate \tcode{depth(bfs)} and returns a different value than \tcode{size(bfs)}.

The following example shows how the functions  could be used, using \tcode{dfs} for one of the depth\_first\_search views. The same functions can be used for all all search views.
\begin{lstlisting}
auto&& g = ...; // graph
auto&& dfs = vertices_dfs(g,0); // start with vertex\_id=0
for(auto&& [vid,v] : dfs) {
  // No need to search deeper?
  if(depth(dfs) > 3) {
    cancel(dfs,cancel_search::cancel_branch);
    continue;
  }
  
  if(size(dfs) > 1000) {
    std::cout << "Big depth of " << size(dfs) << '\n';
  }
  
  // do useful things
}
\end{lstlisting}

The range returned by \textit{sourced} views (includes source\_id) adheres to the  \tcode{basic_sourced_index_edgelist} concept. If a 
\tcode{evf(uv)} function is passed, it also adheres to the \tcode{has_edge_value} concept.

\subsection{Depth First Search Views}

Depth First Search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_descriptor} or \tcode{edge_descriptor} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:dfs} shows the functions and their return values.

The \tcode{alloc} parameter shown in the following examples is optional and defaults to \tcode{std::allocator<bool>}. It is used for containers 
that are internal to the view. The \tcode{bool} argument has no particular meaning.

\tcode{vertices_dfs} views require a \tcode{vvf(u)} function, and the \tcode{basic_vertices_dfs} views require a \tcode{vvf(uid)} function.
\tcode{edges_dfs} views require a \tcode{evf(uv)} function. \tcode{basic_sourced_edges_dfs} views require a \tcode{evf(eid)} function. 
A \tcode{basic_edges_dfs} view with a evf is not available because \tcode{evf(eid)} requires that the \tcode{source_id} is available.

% basic_edges_dfs(g,seed,evf) implies the use of Sourced type internally to have source_id in the call call to evf(eid)

\phil{Consider adding an enum bitset of events matching the visitor events, and creating Overloads
      that accept the bitset. The returned type would be a subclass of \tcode{vertex_descriptor} or \tcode{edge_descriptor}
      and would add the event bitset as a final member value, with the bit set for the event . This could offer a similar benefit as
      coroutines.}

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_dfs(g,seed,alloc))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_dfs(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,V,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid,uv] : edges_dfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_dfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,E,EV>} \\
\hdashline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_dfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_dfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,E,EV>} \\
\hline
    \tcode{for(auto\&\& [vid] : basic_vertices_dfs(g,seed,alloc))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_vertices_dfs(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,void,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid] : basic_edges_dfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_edges_dfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,void,EV>} \\ % requires source_ for evf(eid)
\hdashline
    \tcode{for(auto\&\& [uid,vid] : basic_sourced_edges_dfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,void,void>} \\
    \tcode{for(auto\&\& [uid,vid,val] : basic_sourced_edges_dfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,void,EV>} \\
\hline
\end{tabular}}
\caption{depth\_first\_search View Functions}
\label{tab:dfs}
\end{center}
\end{table}

\subsection{Breadth First Search Views}
\phil{NetworkX provides an optional depth\_limit parameter for bfs. Add? }

Breadth First Search views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_descriptor} 
or \tcode{edge_descriptor} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:bfs} shows the functions and their return values.

The \tcode{alloc} parameter shown in the following examples is optional and defaults to \tcode{std::allocator<bool>}. It is used for containers 
that are internal to the view. The \tcode{bool} argument has no particular meaning.

\tcode{vertices_bfs} views require a \tcode{vvf(u)} function, and the \tcode{basic_vertices_bfs} views require a \tcode{vvf(uid)} function.
\tcode{edges_bfs} views require a \tcode{evf(uv)} function.

\tcode{basic_sourced_edges_bfs} views require a \tcode{evf(eid)} function. 
A \tcode{basic_edges_bfs} view with a evf is not available because \tcode{evf(eid)} requires that the \tcode{source_id} is available.

% basic_edges_bfs(g,seed,evf) implies the use of Sourced type internally to have source_id in the call call to evf(eid)

\phil{Consider adding an enum bitset of events matching the visitor events, and creating Overloads
      that accept the bitset. The returned type would be a subclass of \tcode{vertex_descriptor} or \tcode{edge_descriptor}
      and would add the event bitset as a final member value, with the bit set for the event . This could offer a similar benefit as
      coroutines.}

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
\hdashline
    \tcode{for(auto\&\& [vid,v] : vertices_bfs(g,seed,alloc))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_bfs(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,V,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid,uv] : edges_bfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_bfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,E,EV>} \\
\hdashline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_bfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_bfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,E,EV>} \\
\hline
    \tcode{for(auto\&\& [vid] : basic_vertices_bfs(g,seed,alloc))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_vertices_bfs(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,void,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid] : basic_edges_bfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_edges_bfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,void,EV>} \\ % requires source_ for evf(eid)
\hdashline
    \tcode{for(auto\&\& [uid,vid] : basic_sourced_edges_bfs(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,void,void>} \\
    \tcode{for(auto\&\& [uid,vid,val] : basic_sourced_edges_bfs(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,void,EV>} \\
\hline
\end{tabular}}
\caption{breadth\_first\_search View Functions}
\label{tab:bfs}
\end{center}
\end{table}

\subsection{Topological Sort Views}
Topological Sort views iterate over the vertices and edges from a given seed vertex, returning a \tcode{vertex_descriptor} or 
\tcode{edge_descriptor} on each iteration when it is first encountered, depending on the function used. 
Table \ref{tab:topo_sort} shows the functions and their return values.

The \tcode{alloc} parameter shown in the following examples is optional and defaults to \tcode{std::allocator<bool>}. It is used for containers 
that are internal to the view. The \tcode{bool} argument has no particular meaning.

\tcode{vertices_topological_sort} views require a \tcode{vvf(u)} function, and the \tcode{basic_vertices_topological_sort} views require a \tcode{vvf(uid)} function.
\tcode{edges_topological_sort} views require a \tcode{evf(uv)} function. 

% basic_edges_topological_sort(g,seed,evf) implies the use of Sourced type internally to have source_id in the call call to evf(eid)

\phil{Consider adding an enum bitset of events matching the visitor events, and creating Overloads
      that accept the bitset. The returned type would be a subclass of \tcode{vertex_descriptor} or \tcode{edge_descriptor}
      and would add the event bitset as a final member value, with the bit set for the event . This could offer a similar benefit as
      coroutines.}

\begin{table}[h!]
\begin{center}
\resizebox{\textwidth}{!}
{\begin{tabular}{l l}
\hline
    \textbf{Example} & \textbf{Return} \\
\hline
    \tcode{for(auto\&\& [vid,v] : vertices_topological_sort(g,seed,alloc))} & \tcode{vertex_descriptor<VId,V,void>} \\
    \tcode{for(auto\&\& [vid,v,val] : vertices_topological_sort(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,V,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid,uv] : edges_topological_sort(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,E,void>} \\
    \tcode{for(auto\&\& [vid,uv,val] : edges_topological_sort(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,E,EV>} \\
\hdashline
    \tcode{for(auto\&\& [uid,vid,uv] : sourced_edges_topological_sort(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,E,void>} \\
    \tcode{for(auto\&\& [uid,vid,uv,val] : sourced_edges_topological_sort(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,E,EV>} \\
\hline
    \tcode{for(auto\&\& [vid] : basic_vertices_topological_sort(g,seed,alloc))} & \tcode{vertex_descriptor<VId,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_vertices_topological_sort(g,seed,vvf,alloc))} & \tcode{vertex_descriptor<VId,void,VV>} \\
\hdashline
    \tcode{for(auto\&\& [vid] : basic_edges_topological_sort(g,seed,alloc))} & \tcode{edge_descriptor<VId,false,void,void>} \\
    \tcode{for(auto\&\& [vid,val] : basic_edges_topological_sort(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,false,void,EV>} \\ % requires source_ for evf(eid)
\hdashline
    \tcode{for(auto\&\& [uid,vid] : basic_sourced_edges_topological_sort(g,seed,alloc))} & \tcode{edge_descriptor<VId,true,void,void>} \\
    \tcode{for(auto\&\& [uid,vid,val] : basic_sourced_edges_topological_sort(g,seed,evf,alloc))} & \tcode{edge_descriptor<VId,true,void,EV>} \\
\hline
\end{tabular}}
\caption{topological\_sort View Functions}
\label{tab:topo_sort}
\end{center}
\end{table}

